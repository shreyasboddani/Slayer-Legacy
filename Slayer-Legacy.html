<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Demon Slayer: Final Confrontation</title>
    <meta name="description"
        content="An evolved 2D Demon Slayer game featuring Hashira assists, dialogue, and advanced combat mechanics.">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@700&display=swap');

        html,
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            color: #fff;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-family: 'Cinzel', serif;
        }

        canvas {
            background-color: #0a0814;
            image-rendering: pixelated;
            border: 3px solid #302a4d;
            box-shadow: 0 0 15px #c386f1, 0 0 45px #c386f1, inset 0 0 20px rgba(0, 0, 0, 0.5);
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .hud-bar {
            position: absolute;
            top: 20px;
            background: rgba(10, 8, 20, 0.7);
            border: 1px solid #302a4d;
            border-radius: 5px;
            overflow: hidden;
            padding: 2px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .bar-inner {
            height: 20px;
            border-radius: 3px;
            transition: width 0.2s ease-out;
        }

        #hp-bar {
            left: 20px;
            width: 250px;
        }

        #hp-bar-inner {
            background: linear-gradient(90deg, #e53935, #b71c1c);
        }

        #focus-bar {
            left: 20px;
            top: 50px;
            width: 200px;
        }

        #focus-bar-inner {
            background: linear-gradient(90deg, #42a5f5, #1976d2);
        }

        #boss-hud {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            opacity: 0;
            transition: opacity 0.5s;
            text-align: center;
        }

        #boss-name {
            font-size: 18px;
            text-shadow: 0 0 8px #000;
            margin-bottom: 5px;
        }

        #boss-hp-bar {
            position: relative;
            left: auto;
            top: auto;
            transform: none;
            width: 100%;
        }

        #boss-hp-bar-inner {
            background: linear-gradient(90deg, #d81b60, #880e4f);
        }

        #boss-status-icon {
            position: absolute;
            right: -30px;
            top: 5px;
            font-size: 20px;
        }

        #skill-hud {
            position: absolute;
            left: 20px;
            top: 80px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        #style-indicator {
            font-size: 16px;
            margin-bottom: 5px;
            text-shadow: 0 0 8px #fff;
        }

        .skill-container {
            display: flex;
            gap: 10px;
        }

        .skill-icon {
            width: 40px;
            height: 40px;
            background: rgba(10, 8, 20, 0.7);
            border: 1px solid #302a4d;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .cooldown-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(0, 0, 0, 0.8);
            transition: height 0.1s linear;
        }

        #hashira-hud {
            position: absolute;
            right: 20px;
            top: 20px;
            background: rgba(10, 8, 20, 0.7);
            border: 1px solid #302a4d;
            padding: 8px;
            border-radius: 5px;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }

        #hashira-name {
            font-size: 14px;
            margin-bottom: 4px;
        }

        #hashira-state {
            font-size: 12px;
            color: #ccc;
        }

        #dialogue-box {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 800px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #302a4d;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 0 20px #c386f1;
            z-index: 20;
            display: none;
            pointer-events: all;
            cursor: pointer;
        }

        #speaker-name {
            font-size: 22px;
            color: #c386f1;
            margin-bottom: 10px;
        }

        #dialogue-text {
            font-size: 18px;
            line-height: 1.5;
        }

        .game-screen {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 10;
            text-align: center;
            backdrop-filter: blur(5px);
        }

        .game-screen h1 {
            font-size: 48px;
            text-shadow: 0 0 15px #c386f1;
        }

        .game-screen p {
            font-size: 20px;
            margin-top: -10px;
        }

        .game-screen .controls {
            font-size: 16px;
            margin-top: 40px;
            line-height: 1.8;
            color: #ccc;
        }
    </style>
</head>

<body>
    <canvas id="gameCanvas"></canvas>
    <div id="ui-overlay">
        <div id="hp-bar" class="hud-bar">
            <div id="hp-bar-inner" class="bar-inner"></div>
        </div>
        <div id="focus-bar" class="hud-bar">
            <div id="focus-bar-inner" class="bar-inner"></div>
        </div>

        <div id="boss-hud">
            <div id="boss-name"></div>
            <div id="boss-hp-bar" class="hud-bar">
                <div id="boss-hp-bar-inner" class="bar-inner"></div>
                <div id="boss-status-icon"></div>
            </div>
        </div>

        <div id="skill-hud">
            <div id="style-indicator">Water Breathing</div>
            <div class="skill-container">
                <div class="skill-icon">F<div id="skillF-cooldown" class="cooldown-overlay"></div>
                </div>
                <div class="skill-icon">X<div id="skillX-cooldown" class="cooldown-overlay"></div>
                </div>
                <div class="skill-icon">1<div id="skill1-cooldown" class="cooldown-overlay"></div>
                </div>
                <div class="skill-icon">2<div id="skill2-cooldown" class="cooldown-overlay"></div>
                </div>
                <div class="skill-icon">3<div id="skill3-cooldown" class="cooldown-overlay"></div>
                </div>
            </div>
        </div>

        <div id="hashira-hud">
            <div id="hashira-name"></div>
            <div id="hashira-state"></div>
        </div>
    </div>

    <div id="dialogue-box">
        <div id="speaker-name"></div>
        <div id="dialogue-text"></div>
    </div>

    <div id="start-screen" class="game-screen">
        <h1>Demon Slayer: Final Confrontation</h1>
        <p>Click to Begin</p>
        <div class="controls">
            [A][D] - Move | [W] - Jump/Double Jump | [C] - Dash<br>
            [Q] - Switch Breathing Style | [F] - Parry | [X] - Basic Attack | [1][2][3] - Special Attacks
        </div>
    </div>
    <div id="game-over-screen" class="game-screen" style="display: none;">
        <h1>You Have Fallen</h1>
        <p>Click to Restart</p>
    </div>
    <div id="victory-screen" class="game-screen" style="display: none;">
        <h1>Victory</h1>
        <p>You have defeated the Upper Moons!</p>
        <div class="controls">Click to Play Again</div>
    </div>

    <script>
        // ##################################################################
        // #                           SETUP                              #
        // ##################################################################
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const GAME_WIDTH = 1280;
        const GAME_HEIGHT = 720;
        canvas.width = GAME_WIDTH;
        canvas.height = GAME_HEIGHT;

        // ##################################################################
        // #                          SYSTEMS                             #
        // ##################################################################

        // --- Audio Engine ---
        const audio = {
            ctx: null,
            init() { if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); },
            playSound(type, volume = 0.5, duration = 0.1) {
                if (!this.ctx) return;
                const o = this.ctx.createOscillator();
                const g = this.ctx.createGain();
                g.gain.setValueAtTime(volume, this.ctx.currentTime);
                g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
                let freq = 100, wave = 'triangle';
                switch (type) {
                    case 'jump': freq = 440; break;
                    case 'slash': freq = 220; g.gain.setValueAtTime(volume * 0.5, this.ctx.currentTime); wave = 'square'; break;
                    case 'dash': freq = 880; duration = 0.15; break;
                    case 'hit_player': freq = 150; duration = 0.2; break;
                    case 'hit_enemy': freq = 300; wave = 'square'; break;
                    case 'skill_water': freq = 600; duration = 0.4; break;
                    case 'skill_fire': freq = 250; duration = 0.5; wave = 'sawtooth'; break;
                    case 'skill_ice': freq = 700; duration = 0.6; wave = 'sine'; break;
                    case 'skill_moon': freq = 180; duration = 0.7; wave = 'sawtooth'; break;
                    case 'switch_style': freq = 1000; duration = 0.05; break;
                    case 'heal': freq = 800; wave = 'sine'; duration = 0.3; break;
                    case 'parry_success': freq = 1200; wave = 'sine'; duration = 0.2; break;
                    case 'parry_fail': freq = 100; wave = 'square'; duration = 0.1; break;
                }
                o.type = wave;
                o.frequency.setValueAtTime(freq, this.ctx.currentTime);
                o.connect(g);
                g.connect(this.ctx.destination);
                o.start(this.ctx.currentTime);
                o.stop(this.ctx.currentTime + duration);
            }
        };

        // --- Input Handler ---
        const input = { left: false, right: false, jump: false, dash: false, attack: false, skill1: false, skill2: false, skill3: false, switchStyle: false, parry: false };
        const keysToTrack = ['jump', 'dash', 'attack', 'skill1', 'skill2', 'skill3', 'switchStyle', 'parry'];
        keysToTrack.forEach(key => input[key + 'Pressed'] = false);
        window.addEventListener('keydown', handleKeyEvent);
        window.addEventListener('keyup', handleKeyEvent);
        function handleKeyEvent(e) {
            if (dialogueManager.isActive) return;
            const state = e.type === 'keydown';
            switch (e.code) {
                case 'KeyA': case 'ArrowLeft': input.left = state; break;
                case 'KeyD': case 'ArrowRight': input.right = state; break;
                case 'KeyW': case 'ArrowUp': if (state && !input.jump) input.jumpPressed = true; input.jump = state; break;
                case 'KeyC': if (state && !input.dash) input.dashPressed = true; input.dash = state; break;
                case 'KeyX': if (state && !input.attack) input.attackPressed = true; input.attack = state; break;
                case 'Digit1': if (state && !input.skill1) input.skill1Pressed = true; input.skill1 = state; break;
                case 'Digit2': if (state && !input.skill2) input.skill2Pressed = true; input.skill2 = state; break;
                case 'Digit3': if (state && !input.skill3) input.skill3Pressed = true; input.skill3 = state; break;
                case 'KeyQ': if (state && !input.switchStyle) input.switchStylePressed = true; input.switchStyle = state; break;
                case 'KeyF': if (state && !input.parry) input.parryPressed = true; input.parry = state; break;
            }
        }

        // --- Particle Engine ---
        class Particle {
            constructor(config) { Object.assign(this, { age: 0, ...config }); }
            update(dt) { this.vx *= this.drag || 0.99; this.vy *= this.drag || 0.99; this.vy += this.gravity * dt; this.x += this.vx * dt; this.y += this.vy * dt; this.age += dt; if (this.size > 0.1) this.size *= this.shrink || 0.97; }
            draw(ctx) {
                ctx.globalAlpha = 1 - (this.age / this.lifetime);
                if (this.glow) { ctx.shadowColor = this.color; ctx.shadowBlur = this.size * 1.5; }
                ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
                ctx.shadowBlur = 0; ctx.globalAlpha = 1;
            }
            isDead() { return this.age >= this.lifetime || this.size < 0.2; }
        }
        const particleManager = {
            particles: [],
            spawn(config) {
                const { x, y, count, color, speed, size, lifetime, angle = 0, spread = Math.PI * 2, gravity = 0, ...rest } = config;
                for (let i = 0; i < count; i++) {
                    const currentAngle = angle - spread / 2 + Math.random() * spread;
                    const currentSpeed = (typeof speed === 'number') ? Math.random() * speed : speed[0] + Math.random() * (speed[1] - speed[0]);
                    const vx = Math.cos(currentAngle) * currentSpeed; const vy = Math.sin(currentAngle) * currentSpeed;
                    const pSize = (typeof size === 'number') ? Math.random() * size + 1 : size[0] + Math.random() * (size[1] - size[0]);
                    this.particles.push(new Particle({ x, y, vx, vy, size: pSize, color, lifetime: Math.random() * lifetime + 0.2, gravity, ...rest }));
                }
            },
            update(dt) { for (let i = this.particles.length - 1; i >= 0; i--) { this.particles[i].update(dt); if (this.particles[i].isDead()) this.particles.splice(i, 1); } },
            draw(ctx) { this.particles.forEach(p => p.draw(ctx)); }
        };

        // --- Dialogue Manager ---
        const dialogueManager = {
            isActive: false, sequence: [], currentIndex: 0, currentText: '', charIndex: 0,
            dialogueBox: document.getElementById('dialogue-box'),
            speakerName: document.getElementById('speaker-name'),
            dialogueText: document.getElementById('dialogue-text'),
            start(sequence) {
                this.sequence = sequence; this.isActive = true; this.currentIndex = 0;
                this.dialogueBox.style.display = 'block'; this.loadMessage();
                this.dialogueBox.onclick = () => this.next();
            },
            loadMessage() {
                if (this.currentIndex >= this.sequence.length) { this.end(); return; }
                const msg = this.sequence[this.currentIndex];
                this.speakerName.textContent = msg.speaker; this.dialogueText.textContent = '';
                this.currentText = msg.text; this.charIndex = 0;
            },
            update(dt) {
                if (!this.isActive || this.charIndex >= this.currentText.length) return;
                this.charIndex += 50 * dt;
                this.dialogueText.textContent = this.currentText.substring(0, Math.floor(this.charIndex));
            },
            next() {
                if (this.charIndex < this.currentText.length) {
                    this.charIndex = this.currentText.length;
                    this.dialogueText.textContent = this.currentText;
                } else {
                    this.currentIndex++; this.loadMessage();
                }
            },
            end() {
                this.isActive = false; this.dialogueBox.style.display = 'none';
                this.dialogueBox.onclick = null; game.state = 'playing';
            }
        };

        // --- Screen Effects ---
        const screenEffects = {
            shakeTimer: 0, intensity: 0,
            shake(duration, intensity) { this.shakeTimer = Math.max(this.shakeTimer, duration); this.intensity = Math.max(this.intensity, intensity); },
            update(dt) { if (this.shakeTimer > 0) { this.shakeTimer -= dt; if (this.shakeTimer <= 0) this.intensity = 0; } },
            apply(ctx) { if (this.shakeTimer > 0) { ctx.translate((Math.random() - 0.5) * this.intensity, (Math.random() - 0.5) * this.intensity); } }
        };

        // --- Camera ---
        class Camera {
            constructor(w, h) { this.x = 0; this.y = 0; this.width = w; this.height = h; this.smoothSpeed = 0.08; }
            follow(target, level) {
                let tX = target.x + target.w / 2 - this.width / 2; let tY = target.y + target.h / 2 - this.height / 2;
                this.x += (tX - this.x) * this.smoothSpeed; this.y += (tY - this.y) * this.smoothSpeed;
                this.x = Math.max(level.x, Math.min(this.x, level.w - this.width)); this.y = Math.max(level.y, Math.min(this.y, level.h - this.height));
            }
            apply(ctx) { ctx.save(); screenEffects.apply(ctx); ctx.translate(-this.x, -this.y); }
            release(ctx) { ctx.restore(); }
        }

        // ##################################################################
        // #                        WORLD & MAP                           #
        // ##################################################################
        class HealingOrb {
            constructor(x, y) { this.x = x; this.y = y; this.w = 24; this.h = 24; this.active = true; this.bobOffset = 0; this.bobSpeed = 2; }
            update(dt) { this.bobOffset = Math.sin(performance.now() / 1000 * this.bobSpeed) * 5; }
            draw(ctx) {
                if (!this.active) return;
                ctx.save(); ctx.shadowColor = '#4caf50'; ctx.shadowBlur = 20;
                ctx.fillStyle = 'rgba(76, 175, 80, 0.3)';
                ctx.beginPath(); ctx.arc(this.x + this.w / 2, this.y + this.h / 2 + this.bobOffset, this.w, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#81c784';
                ctx.beginPath(); ctx.arc(this.x + this.w / 2, this.y + this.h / 2 + this.bobOffset, this.w / 2, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
            }
        }
        class InfinityCastleBackground {
            constructor() { this.structures = []; this.generateStructures(); }
            generateStructures() {
                for (let i = 0; i < 50; i++) { this.structures.push({ x: Math.random() * 4000 - 1000, y: Math.random() * 3000 - 1000, w: Math.random() * 300 + 100, h: Math.random() * 20 + 10, depth: Math.random() * 0.5 + 0.1, angle: Math.random() * Math.PI, color: `rgba(75, 68, 110, ${Math.random() * 0.2 + 0.1})` }); }
                for (let i = 0; i < 20; i++) { this.structures.push({ x: Math.random() * 4000 - 1000, y: Math.random() * 3000 - 1000, w: Math.random() * 20 + 10, h: Math.random() * 300 + 100, depth: Math.random() * 0.6 + 0.2, angle: Math.random() * Math.PI, color: `rgba(95, 88, 130, ${Math.random() * 0.2 + 0.1})` }); }
            }
            update(dt) { }
            draw(ctx, camera) {
                ctx.save(); ctx.fillStyle = '#0a0814'; ctx.fillRect(camera.x, camera.y, camera.width, camera.height);
                this.structures.forEach(s => {
                    const parallaxX = camera.x * s.depth; const parallaxY = camera.y * s.depth;
                    ctx.save(); ctx.translate(s.x - parallaxX, s.y - parallaxY); ctx.rotate(s.angle);
                    ctx.fillStyle = s.color; ctx.fillRect(-s.w / 2, -s.h / 2, s.w, s.h);
                    ctx.strokeStyle = "rgba(0,0,0,0.3)"; ctx.lineWidth = 1; ctx.strokeRect(-s.w / 2, -s.h / 2, s.w, s.h);
                    ctx.restore();
                });
                ctx.save(); ctx.strokeStyle = "rgba(123, 91, 188, 0.05)"; ctx.lineWidth = 2;
                ctx.translate(camera.x + camera.width / 2, camera.y + camera.height / 2); ctx.rotate(performance.now() / 50000);
                const size = 200;
                for (let i = -10; i < 10; i++) {
                    ctx.beginPath(); ctx.moveTo(i * size, -10 * size); ctx.lineTo(i * size, 10 * size); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(-10 * size, i * size); ctx.lineTo(10 * size, i * size); ctx.stroke();
                }
                ctx.restore(); ctx.restore();
            }
        }
        class Tile {
            constructor(x, y, w, h, type = 'solid') {
                Object.assign(this, { x, y, w, h, type, initialX: x, initialY: y });
                if (type === 'moving_h') this.vx = 70;
                if (type === 'moving_v') this.vy = 70;
            }
            update(dt) {
                if (this.type === 'moving_h') { this.x += this.vx * dt; if (Math.abs(this.x - this.initialX) > 150) this.vx *= -1; }
                if (this.type === 'moving_v') { this.y += this.vy * dt; if (Math.abs(this.y - this.initialY) > 100) this.vy *= -1; }
            }
            draw(ctx) {
                if (this.type === 'spike') {
                    ctx.fillStyle = '#ff4d4d'; ctx.beginPath();
                    for (let i = 0; i < this.w / 16; i++) { ctx.moveTo(this.x + i * 16, this.y + 16); ctx.lineTo(this.x + i * 16 + 8, this.y); ctx.lineTo(this.x + i * 16 + 16, this.y + 16); }
                    ctx.closePath(); ctx.fill();
                } else {
                    const gradient = ctx.createLinearGradient(this.x, this.y, this.x, this.y + this.h);
                    gradient.addColorStop(0, '#5a5278'); gradient.addColorStop(1, '#302a4d');
                    ctx.fillStyle = gradient; ctx.fillRect(this.x, this.y, this.w, this.h);
                    ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 2;
                    ctx.beginPath();
                    for (let i = 0; i < this.h; i += 10) { ctx.moveTo(this.x, this.y + i); ctx.lineTo(this.x + this.w, this.y + i); }
                    ctx.stroke();
                }
            }
        }
        class Door {
            constructor(x, y, w, h, to, eX, eY, lockedCondition = () => false) { Object.assign(this, { x, y, w, h, toRoom: to, entryX: eX, entryY: eY, lockedCondition }); }
            isLocked() { return this.lockedCondition(); }
            draw(ctx) {
                if (this.isLocked()) {
                    ctx.fillStyle = 'rgba(255, 50, 50, 0.4)'; ctx.strokeStyle = '#ff0000'; ctx.lineWidth = 2;
                    ctx.fillRect(this.x, this.y, this.w, this.h); ctx.strokeRect(this.x, this.y, this.w, this.h);
                } else {
                    ctx.fillStyle = 'rgba(255, 223, 186, 0.4)'; ctx.fillRect(this.x, this.y, this.w, this.h);
                }
            }
        }
        class Room {
            constructor(c) {
                Object.assign(this, { tiles: [], doors: [], bosses: [], healingOrbs: [], hashira: null, background: new InfinityCastleBackground(), ...c });
                this.bosses.forEach(b => b.room = this);
                if (this.hashira) this.hashira.room = this;
            }
            update(dt) {
                this.background.update(dt);
                this.tiles.forEach(t => t.update(dt));
                this.healingOrbs.forEach(o => o.update(dt));
                this.bosses.forEach(b => { if (b.active) b.update(dt, game.player, this.hashira) });
                if (this.hashira && this.hashira.active) this.hashira.update(dt, game.player, this.getActiveBoss());
            }
            draw(ctx, camera) {
                this.background.draw(ctx, camera, this);
                this.tiles.forEach(t => t.draw(ctx));
                this.doors.forEach(d => d.draw(ctx));
                this.healingOrbs.forEach(o => o.draw(ctx));
                if (this.hashira) this.hashira.draw(ctx);
                this.bosses.forEach(b => b.draw(ctx));
            }
            getActiveBoss() { return this.bosses.find(b => b.active && b.hp > 0); }
            reset() {
                this.bosses.forEach(b => b.reset());
                this.healingOrbs.forEach(o => o.active = true);
                if (this.hashira) this.hashira.reset();
            }
        }

        // ##################################################################
        // #                         ENTITIES                             #
        // ##################################################################
        class Player {
            constructor(x, y) {
                this.w = 32; this.h = 56;
                this.baseStats = { speed: 280, jumpForce: 700, gravity: 1800, maxHp: 100, maxFocus: 100 };
                this.reset(x, y);
            }
            reset(x, y) {
                this.endAttack();
                Object.assign(this, this.baseStats, {
                    x, y, vx: 0, vy: 0, facing: 1, onGround: false, onWall: false, wallSlideSpeed: 150, jumpCount: 0,
                    isDashing: false, dashTimer: 0, dashCooldown: 0, isParrying: false, parryTimer: 0, parryCooldown: 0,
                    invulnerableTimer: 0, hp: this.baseStats.maxHp, focus: this.baseStats.maxFocus, currentStyle: 0,
                    skills: [
                        { // Water Breathing
                            'F': { cooldown: 0, maxCooldown: 1.0, cost: 0 }, 'X': { cooldown: 0, maxCooldown: 0.3, cost: 0 },
                            '1': { cooldown: 0, maxCooldown: 2, cost: 20 }, '2': { cooldown: 0, maxCooldown: 4, cost: 35 },
                            '3': { cooldown: 0, maxCooldown: 8, cost: 50 },
                        },
                        { // Hinokami Kagura
                            'F': { cooldown: 0, maxCooldown: 1.0, cost: 0 }, 'X': { cooldown: 0, maxCooldown: 0.4, cost: 5 },
                            '1': { cooldown: 0, maxCooldown: 3, cost: 30 }, '2': { cooldown: 0, maxCooldown: 6, cost: 45 },
                            '3': { cooldown: 0, maxCooldown: 10, cost: 70 },
                        }
                    ],
                    activeAttack: null
                });
            }
            update(dt, level) {
                ['dashCooldown', 'invulnerableTimer', 'parryCooldown'].forEach(t => { if (this[t] > 0) this[t] -= dt; });
                this.skills.forEach(style => Object.values(style).forEach(s => { if (s.cooldown > 0) s.cooldown -= dt; }));
                this.focus = Math.min(this.maxFocus, this.focus + 15 * dt);
                if (this.isParrying) { this.parryTimer -= dt; if (this.parryTimer <= 0) this.isParrying = false; }
                if (this.activeAttack) { this.activeAttack.timer -= dt; if (this.activeAttack.timer <= 0) this.endAttack(); }
                if (!this.isDashing && !this.activeAttack) { this.vx = 0; if (input.left) { this.vx = -this.speed; this.facing = -1; } if (input.right) { this.vx = this.speed; this.facing = 1; } }
                if (input.dashPressed && this.dashCooldown <= 0 && !this.activeAttack) {
                    this.isDashing = true; this.dashTimer = 0.15; this.vx = this.facing * 700; this.vy = 0; this.dashCooldown = 0.6; audio.playSound('dash');
                    particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h / 2, count: 20, color: '#a7d8f5', speed: 150, size: 4, lifetime: 0.4, glow: true });
                }
                if (this.isDashing) { this.dashTimer -= dt; if (this.dashTimer <= 0) this.isDashing = false; }
                if (!this.activeAttack) {
                    if (input.switchStylePressed) {
                        this.currentStyle = (this.currentStyle + 1) % 2; audio.playSound('switch_style');
                        particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h / 2, count: 25, color: this.currentStyle === 0 ? '#42a5f5' : '#ff7043', speed: 100, size: 4, lifetime: 0.5, glow: true });
                    }
                    const style = this.skills[this.currentStyle];
                    if (input.parryPressed && style['F'].cooldown <= 0) this.useSkill('F');
                    else if (input.attackPressed && style['X'].cooldown <= 0 && this.focus >= style['X'].cost) this.useSkill('X');
                    else if (input.skill1Pressed && style['1'].cooldown <= 0 && this.focus >= style['1'].cost) this.useSkill('1');
                    else if (input.skill2Pressed && style['2'].cooldown <= 0 && this.focus >= style['2'].cost) this.useSkill('2');
                    else if (input.skill3Pressed && style['3'].cooldown <= 0 && this.focus >= style['3'].cost) this.useSkill('3');
                }
                if (!this.isDashing) { this.vy += this.gravity * dt; }
                if (input.jumpPressed && !this.activeAttack) {
                    if (this.onGround) { this.vy = -this.jumpForce; this.jumpCount = 1; audio.playSound('jump'); particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h, count: 5, color: '#ccc', speed: 100, size: 3, lifetime: 0.3, angle: -Math.PI / 2, spread: Math.PI / 2 }); }
                    else if (this.jumpCount < 2 && !this.onWall) { this.vy = -this.jumpForce * 0.9; this.jumpCount = 2; audio.playSound('jump', 0.8); }
                    else if (this.onWall) { this.vy = -this.jumpForce; this.vx = -this.facing * this.speed * 1.2; this.onWall = false; audio.playSound('jump'); }
                }
                if (this.onWall && !this.onGround && this.vy > 0) { this.vy = Math.min(this.vy, this.wallSlideSpeed); if (Math.random() < 0.2) particleManager.spawn({ x: this.facing > 0 ? this.x + this.w : this.x, y: this.y + Math.random() * this.h, count: 1, color: '#ccc', speed: 20, size: 2, lifetime: 0.2 }); }
                this.x += this.vx * dt; this.handleCollisions(level.tiles, 'x');
                this.y += this.vy * dt; this.handleCollisions(level.tiles, 'y');
                if (this.hp <= 0) game.setState('gameOver');
            }
            endAttack() {
                if (!this.activeAttack) return;
                if (this.activeAttack.intervalId) clearInterval(this.activeAttack.intervalId);
                if (this.activeAttack.isForcedDash) this.isDashing = false;
                this.activeAttack = null;
            }
            useSkill(key) {
                const style = this.skills[this.currentStyle];
                const skill = style[key];
                if (this.focus < skill.cost) return;
                this.focus -= skill.cost;
                skill.cooldown = skill.maxCooldown;
                if (key === 'F') {
                    this.isParrying = true; this.parryTimer = 0.15; audio.playSound('parry_fail', 0.3);
                    particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h / 2, count: 1, color: '#FFFFFF', speed: 0, size: this.w, lifetime: 0.15, shrink: 0.8, glow: true });
                    return;
                }
                this.activeAttack = { key, timer: 0, intervalId: null, isForcedDash: false };
                if (this.currentStyle === 0) { // Water Breathing
                    audio.playSound('skill_water');
                    if (key === 'X') {
                        this.activeAttack.timer = 0.25; const hX = this.x + (this.facing > 0 ? this.w : -48); game.checkPlayerAttack(hX, this.y, 48, this.h, 5);
                        for (let i = 0; i < 3; i++) setTimeout(() => particleManager.spawn({ x: hX + (this.facing * i * 15), y: this.y + this.h / 2, count: 3, color: '#58b1e0', speed: 50, size: 3, lifetime: 0.3, angle: this.facing > 0 ? 0 : Math.PI, spread: 0.5, glow: true }), i * 50);
                    } else if (key === '1') {
                        this.activeAttack.timer = 0.5; const hX = this.x + (this.facing > 0 ? this.w : -120); game.checkPlayerAttack(hX, this.y - 10, 120, this.h + 20, 15);
                        particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h / 2, count: 30, color: '#42a5f5', speed: [100, 200], size: [2, 5], lifetime: 0.6, angle: this.facing > 0 ? 0 : Math.PI, spread: Math.PI / 4, glow: true });
                    } else if (key === '2') {
                        this.activeAttack.timer = 0.4; this.vy = -200; this.vx = this.facing * 150;
                        this.activeAttack.intervalId = setInterval(() => {
                            if (!this.activeAttack) return; game.checkPlayerAttack(this.x - 30, this.y - 30, this.w + 60, this.h + 60, 8);
                            particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h / 2, count: 10, color: '#42a5f5', speed: 150, size: 4, lifetime: 0.4, glow: true });
                        }, 50);
                    } else if (key === '3') {
                        this.activeAttack.timer = 0.5; this.activeAttack.isForcedDash = true; this.isDashing = true; this.vx = this.facing * 400;
                        this.activeAttack.intervalId = setInterval(() => {
                            if (!this.activeAttack) return; game.checkPlayerAttack(this.x, this.y, this.w, this.h, 12);
                            particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h / 2, count: 15, color: '#1e88e5', speed: 200, size: 5, lifetime: 0.5, angle: this.facing > 0 ? Math.PI : 0, spread: Math.PI / 2, glow: true });
                        }, 40);
                    }
                }
                else if (this.currentStyle === 1) { // Hinokami Kagura
                    audio.playSound('skill_fire');
                    if (key === 'X') {
                        this.activeAttack.timer = 0.3; const hX = this.x + (this.facing > 0 ? this.w : -56); game.checkPlayerAttack(hX, this.y, 56, this.h, 8);
                        particleManager.spawn({ x: hX + (this.facing * 28), y: this.y + this.h / 2, count: 10, color: '#ff7043', speed: 80, size: 5, lifetime: 0.4, angle: this.facing > 0 ? 0 : Math.PI, spread: 0.6, glow: true });
                    } else if (key === '1') {
                        this.activeAttack.timer = 0.2; game.checkPlayerAttack(this.x - 80, this.y - 80, this.w + 160, this.h + 160, 20); screenEffects.shake(0.2, 8);
                        particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h / 2, count: 60, color: '#ff5722', speed: 300, size: 8, lifetime: 1.0, glow: true });
                    } else if (key === '2') {
                        this.activeAttack.timer = 1.0; this.vy = -this.jumpForce; this.jumpCount = 1; setTimeout(() => { this.vy = 1200; }, 150);
                        this.activeAttack.intervalId = setInterval(() => {
                            if (!this.activeAttack || this.onGround) { this.endAttack(); return; } game.checkPlayerAttack(this.x - 20, this.y, this.w + 40, this.h + 20, 15);
                            particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h, count: 8, color: '#f4511e', speed: 100, size: 6, lifetime: 0.5, angle: Math.PI / 2, spread: Math.PI / 3, glow: true });
                        }, 30);
                    } else if (key === '3') {
                        this.activeAttack.timer = 1.0; this.invulnerableTimer = 1.0;
                        particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h / 2, count: 100, color: '#bf360c', speed: 400, size: [4, 10], lifetime: 1.2, gravity: 200, glow: true });
                        setTimeout(() => {
                            if (!this.activeAttack) return; game.checkPlayerAttack(this.x - 200, this.y - 200, this.w + 400, this.h + 400, 50); screenEffects.shake(0.5, 20);
                        }, 500);
                    }
                }
            }
            handleCollisions(tiles, axis) {
                this.onGround = false; this.onWall = false;
                tiles.forEach(tile => {
                    if (this.x < tile.x + tile.w && this.x + this.w > tile.x && this.y < tile.y + tile.h && this.y + this.h > tile.y) {
                        if (tile.type === 'spike' && this.invulnerableTimer <= 0) { this.takeDamage(10); }
                        else if (tile.type !== 'spike') {
                            if (axis === 'y') {
                                if (this.vy > 0) { this.y = tile.y - this.h; this.vy = 0; this.onGround = true; this.jumpCount = 0; this.dashCooldown = Math.min(this.dashCooldown, 0.1); }
                                else if (this.vy < 0) { this.y = tile.y + tile.h; this.vy = 0; }
                            }
                            if (axis === 'x') {
                                if (this.vx > 0) { this.x = tile.x - this.w; this.onWall = true; }
                                else if (this.vx < 0) { this.x = tile.x + tile.w; this.onWall = true; }
                            }
                        }
                    }
                });
            }
            heal(amount) {
                this.hp = Math.min(this.maxHp, this.hp + amount); audio.playSound('heal');
                particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h / 2, count: 20, color: '#4caf50', speed: 100, size: 4, lifetime: 0.6, gravity: -100, glow: true });
            }
            takeDamage(amount) {
                if (this.invulnerableTimer > 0) return;
                if (this.isParrying) {
                    this.isParrying = false; this.invulnerableTimer = 0.5; audio.playSound('parry_success'); screenEffects.shake(0.1, 10);
                    particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h / 2, count: 50, color: '#FFFF00', speed: 300, size: 5, lifetime: 0.5, glow: true });
                    const hX = this.x + (this.facing > 0 ? this.w : -200); game.checkPlayerAttack(hX, this.y - 20, 200, this.h + 40, 25);
                    return;
                }
                this.hp -= amount; this.invulnerableTimer = 1.0; this.endAttack(); audio.playSound('hit_player'); screenEffects.shake(0.2, 8);
                particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h / 2, count: 15, color: '#ff4d4d', speed: 200, size: 3, lifetime: 0.5 });
            }
            draw(ctx) {
                if (this.invulnerableTimer > 0 && Math.floor(this.invulnerableTimer * 10) % 2 === 0) return;
                ctx.save(); ctx.translate(this.x, this.y);
                if (this.isParrying) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'; ctx.beginPath();
                    ctx.arc(this.w / 2, this.h / 2, this.w, 0, Math.PI * 2); ctx.fill();
                }
                ctx.fillStyle = '#3a3a3a'; ctx.fillRect(4, 16, this.w - 8, this.h - 16);
                ctx.fillStyle = '#ffffff'; ctx.fillRect(10, this.h - 10, this.w - 20, 10);
                const haoriColor = this.currentStyle === 0 ? '#006400' : '#4a0e0e';
                ctx.fillStyle = haoriColor; ctx.fillRect(0, 16, this.w, this.h - 20);
                ctx.fillStyle = this.currentStyle === 0 ? '#000' : '#2a0808';
                for (let i = 0; i < 4; i++) { for (let j = 2; j < 6; j++) { if ((i + j) % 2 === 0) ctx.fillRect(i * (this.w / 4), j * (this.h / 7), this.w / 4, this.h / 7); } }
                ctx.fillStyle = '#ffdab9'; ctx.fillRect(8, 0, 16, 16);
                ctx.fillStyle = '#8b0000'; ctx.fillRect(6, -4, 20, 14);
                ctx.fillRect(2, 4, 28, 6); ctx.fillStyle = '#cd5c5c';
                ctx.fillRect(6, 2, 6, 3);
                ctx.save(); ctx.translate(this.w / 2, this.h / 2);
                if (this.activeAttack) ctx.rotate(this.facing * -Math.PI / 4 * (Math.sin(this.activeAttack.timer * 5) * 0.5 + 0.5));
                const bladeX = this.facing > 0 ? 10 : -50; const handX = this.facing > 0 ? 12 : -12;
                ctx.fillStyle = '#101010'; ctx.fillRect(handX, 2, 4, 10);
                ctx.fillStyle = '#000000'; ctx.fillRect(bladeX, 4, 40, 4);
                ctx.restore(); ctx.restore();
            }
        }

        // ##################################################################
        // #                           HASHIRA                            #
        // ##################################################################
        class Hashira {
            constructor(config) {
                Object.assign(this, { w: 36, h: 60, vx: 0, vy: 0, x: 0, y: 0, active: false, state: 'idle', stateTimer: 2, ...config });
            }
            activate() { this.active = true; this.state = 'idle'; this.stateTimer = 1; }
            reset() { this.active = false; this.x = this.startX; this.y = this.startY; }
            update(dt, player, boss) {
                if (!this.active || !boss) { this.state = 'idle'; return; }
                this.stateTimer -= dt;
                if (this.stateTimer <= 0) { this.chooseAction(player, boss); }
                this.x += this.vx * dt; this.y += this.vy * dt;
            }
            chooseAction(player, boss) { this.state = 'idle'; }
            draw(ctx) { if (!this.active) return; ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.w, this.h); }
        }
        class Giyu extends Hashira {
            constructor(x, y) { super({ name: "Giyu Tomioka", startX: x, startY: y, color: '#0d47a1' }); }
            chooseAction(player, boss) {
                const distance = Math.hypot(this.x - boss.x, this.y - boss.y); const action = Math.random();
                if (action < 0.6 && distance > 100) {
                    this.state = 'moving'; this.stateTimer = 1.5; const angle = Math.atan2(boss.y - this.y, boss.x - this.x);
                    this.vx = Math.cos(angle) * 200;
                } else if (action < 0.85) {
                    this.state = 'attacking'; this.stateTimer = 0.8; this.vx = (boss.x > this.x ? 1 : -1) * 400;
                    setTimeout(() => {
                        if (!this.active) return; game.checkHashiraAttack(this.x, this.y - 10, this.w, this.h + 20, 10, '#4fc3f7');
                        this.vx = 0;
                    }, 300);
                } else {
                    this.state = 'defending'; this.stateTimer = 2.0; this.vx = 0;
                }
            }
            draw(ctx) {
                if (!this.active) return;
                ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.w, this.h);
                ctx.fillStyle = '#b71c1c'; ctx.fillRect(this.x + this.w / 2, this.y, this.w / 2, this.h);
                if (this.state === 'defending') {
                    ctx.strokeStyle = '#4fc3f7'; ctx.lineWidth = 3; ctx.beginPath();
                    ctx.arc(this.x + this.w / 2, this.y + this.h / 2, 50, 0, Math.PI * 2); ctx.stroke();
                }
            }
        }
        class Shinobu extends Hashira {
            constructor(x, y) { super({ name: "Shinobu Kocho", startX: x, startY: y, color: '#6a1b9a' }); }
            chooseAction(player, boss) {
                const action = Math.random();
                if (action < 0.7) {
                    this.state = 'attacking'; this.stateTimer = 1.2;
                    const targetX = boss.x + (Math.random() - 0.5) * 100; const targetY = boss.y - 50;
                    const angle = Math.atan2(targetY - this.y, targetX - this.x);
                    this.vx = Math.cos(angle) * 800; this.vy = Math.sin(angle) * 800;
                    setTimeout(() => {
                        if (!this.active || !boss) return; this.vx = 0; this.vy = 0;
                        game.checkHashiraAttack(boss.x, boss.y, boss.w, boss.h, 5, '#ab47bc'); boss.applyPoison(5, 4);
                    }, 200);
                } else {
                    this.state = 'repositioning'; this.stateTimer = 1.0; const targetX = player.x + (player.facing * -100);
                    const angle = Math.atan2(player.y - this.y, targetX - this.x);
                    this.vx = Math.cos(angle) * 300; this.vy = Math.sin(angle) * 300;
                }
            }
            draw(ctx) {
                if (!this.active) return;
                ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.w, this.h);
                ctx.fillStyle = '#00acc1'; ctx.fillRect(this.x, this.y, this.w, 10);
            }
        }
        class Gyomei extends Hashira {
            constructor(x, y) { super({ name: "Gyomei Himejima", startX: x, startY: y, w: 48, h: 70, color: '#4e342e' }); }
            chooseAction(player, boss) {
                const action = Math.random();
                if (action < 0.6) {
                    this.state = 'attacking'; this.stateTimer = 2.5; this.vx = 0;
                    particleManager.spawn({ x: this.x + this.w / 2, y: this.y, count: 20, color: '#757575', speed: 100, angle: -Math.PI / 2, spread: Math.PI / 2, lifetime: 1.0 });
                    setTimeout(() => {
                        if (!this.active) return;
                        game.checkHashiraAttack(this.x - 100, this.y - 50, this.w + 200, this.h + 50, 20, '#a1887f');
                        screenEffects.shake(0.2, 10);
                    }, 1000);
                } else {
                    this.state = 'moving'; this.stateTimer = 2.0;
                    const angle = Math.atan2(boss.y - this.y, boss.x - this.x); this.vx = Math.cos(angle) * 100;
                }
            }
            draw(ctx) {
                if (!this.active) return;
                ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.w, this.h);
                ctx.fillStyle = '#4caf50'; ctx.beginPath();
                ctx.arc(this.x + this.w / 2, this.y - 10, 20, 0, Math.PI * 2); ctx.fill();
            }
        }

        // ##################################################################
        // #                          BOSSES                              #
        // ##################################################################
        class Boss {
            constructor(config) { Object.assign(this, { w: 64, h: 80, invulnerableTimer: 0, poisonTimer: 0, poisonDps: 0, ...config }); }
            activate() { this.active = true; this.state = 'idle'; this.timer = 2; }
            update(dt, player) {
                if (!this.active || this.hp <= 0) return;
                if (this.invulnerableTimer > 0) this.invulnerableTimer -= dt;
                if (this.poisonTimer > 0) { this.poisonTimer -= dt; this.hp -= this.poisonDps * dt; }
                this.updatePhases(); this.timer -= dt;
                if (this.state === 'transition' && this.timer <= 0) this.state = 'idle';
                if (this.state !== 'transition' && this.timer <= 0) this.chooseAction(player);
                this.executeAction(dt, player);
            }
            updatePhases() { }
            chooseAction(player) { }
            executeAction(dt, player) { }
            takeDamage(amount) {
                if (this.invulnerableTimer > 0 || !this.active || this.state === 'transition') return;
                this.hp -= amount; this.invulnerableTimer = 0.1; game.hitStop = 0.05; audio.playSound('hit_enemy');
                particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h / 2, count: 10, color: '#ffffff', speed: 150, size: 3, lifetime: 0.4 });
                if (this.hp <= 0) this.die();
            }
            applyPoison(duration, dps) { this.poisonTimer = Math.max(this.poisonTimer, duration); this.poisonDps = dps; }
            collidesWith(e) { return this.x < e.x + e.w && this.x + this.w > e.x && this.y < e.y + e.h && this.y + this.h > e.y; }
            die() {
                this.active = false; game.bossDefeated();
                particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h / 2, count: 150, color: this.particleColor, speed: 500, size: 6, lifetime: 2.0, glow: true });
                screenEffects.shake(1.0, 25);
            }
            reset() { this.hp = this.maxHp; this.phase = 1; this.state = 'idle'; this.active = false; this.x = this.startX; this.y = this.startY; this.poisonTimer = 0; }
            draw(ctx) {
                if (!this.active) return;
                if (this.invulnerableTimer > 0 && Math.floor(this.invulnerableTimer * 20) % 2 === 0) return;
                ctx.save();
                if (this.state === 'telegraph') { ctx.globalAlpha = 0.5 + Math.sin(performance.now() / 100) * 0.5; ctx.shadowColor = '#fff'; ctx.shadowBlur = 20; }
                if (this.poisonTimer > 0) ctx.filter = 'sepia(100%) hue-rotate(240deg) saturate(3)';
                let color = this.color;
                if (this.phase === 2) color = this.p2Color;
                if (this.phase === 3) color = this.p3Color;
                ctx.fillStyle = color; ctx.fillRect(this.x, this.y, this.w, this.h);
                this.drawDetails(ctx); ctx.restore();
            }
            drawDetails(ctx) { }
        }
        class Akaza extends Boss {
            constructor(x, y) { super({ name: "Akaza, Upper Moon 3", maxHp: 150, startX: x, startY: y, w: 64, h: 80, color: '#d43d81', p2Color: '#f55f9f', p3Color: '#ff8ac7', particleColor: '#ff69b4' }); }
            updatePhases() {
                if (this.hp < this.maxHp * 0.66 && this.phase === 1) { this.phase = 2; this.state = 'transition'; this.timer = 1.5; screenEffects.shake(0.5, 15); }
                else if (this.hp < this.maxHp * 0.33 && this.phase === 2) { this.phase = 3; this.state = 'transition'; this.timer = 1.5; screenEffects.shake(0.8, 20); }
            }
            chooseAction(p) {
                let a = Math.random();
                if (this.phase === 1) { if (a < 0.8) this.telegraphDash(p, 400); else this.idle(1.5); }
                else if (this.phase === 2) { if (a < 0.6) this.telegraphDash(p, 600); else if (a < 0.9) this.telegraphJump(p); else this.idle(1.0); }
                else if (this.phase === 3) { if (a < 0.4) this.telegraphDash(p, 800); else if (a < 0.7) this.telegraphJump(p); else this.shockwave(); }
            }
            executeAction(dt, player) { if (this.state === 'dash') { this.x += this.vx * dt; this.y += this.vy * dt; if (this.collidesWith(player)) player.takeDamage(15); } }
            idle(d) { this.state = 'idle'; this.timer = d; }
            telegraphDash(p, s) { this.state = 'telegraph'; this.timer = 0.6; const dx = p.x - this.x, dy = p.y - this.y, mag = Math.hypot(dx, dy) || 1; this.vx = (dx / mag) * s; this.vy = (dy / mag) * s; setTimeout(() => { if (this.hp > 0 && this.active) { this.state = 'dash'; this.timer = 0.5; } }, 600); }
            telegraphJump(p) { this.state = 'telegraph'; this.timer = 0.8; this.targetX = p.x; setTimeout(() => { if (this.hp > 0 && this.active) { this.state = 'airborne'; this.x = this.targetX; this.y = p.y - 100; this.timer = 0.5; setTimeout(() => { if (this.hp > 0 && this.active) this.state = 'idle'; }, 500); } }, 800); }
            shockwave() { this.state = 'telegraph'; this.timer = 1.0; setTimeout(() => { if (this.hp > 0 && this.active) { this.state = 'idle'; this.timer = 2.0; particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h, count: 50, color: '#ff69b4', speed: 400, size: 5, lifetime: 1.0, glow: true }); screenEffects.shake(0.3, 10); if (game.player.onGround && game.currentRoom === this.room) game.player.takeDamage(20); } }, 1000); }
            drawDetails(ctx) {
                ctx.fillStyle = '#ffc0cb'; ctx.fillRect(this.x + 12, this.y - 10, this.w - 24, 12); ctx.fillStyle = '#00008b'; ctx.fillRect(this.x + 10, this.y + 20, 4, 40); ctx.fillRect(this.x + this.w - 14, this.y + 20, 4, 40);
                if (this.active && (this.state === 'idle' || this.state === 'telegraph')) {
                    ctx.save(); ctx.translate(this.x + this.w / 2, this.y + this.h);
                    ctx.strokeStyle = '#4dd0e1'; ctx.lineWidth = 2; ctx.globalAlpha = 0.6;
                    for (let i = 0; i < 12; i++) { ctx.rotate(Math.PI / 6); ctx.beginPath(); ctx.moveTo(0, 10); ctx.lineTo(0, 50); ctx.stroke(); }
                    ctx.restore();
                }
            }
        }
        class Doma extends Boss {
            constructor(x, y) { super({ name: "Doma, Upper Moon 2", maxHp: 200, startX: x, startY: y, w: 70, h: 85, color: '#a0d2eb', p2Color: '#4d80e4', p3Color: '#82eefd', particleColor: '#a0d2eb' }); }
            updatePhases() { if (this.hp < this.maxHp * 0.5 && this.phase === 1) { this.phase = 2; this.state = 'transition'; this.timer = 2; screenEffects.shake(0.6, 15); } }
            chooseAction(p) {
                let a = Math.random();
                if (this.phase === 1) { if (a < 0.5) this.iceShards(p); else if (a < 0.9) this.teleport(p); else this.iceClone(); }
                else { if (a < 0.4) this.iceShards(p, 10); else if (a < 0.7) this.teleport(p); else this.freezingCloud(); }
            }
            teleport(p) { this.state = 'telegraph'; this.timer = 0.5; particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h / 2, count: 30, color: '#a0d2eb', speed: 200, size: 5, lifetime: 0.5, glow: true }); setTimeout(() => { if (this.hp > 0 && this.active) { this.x = p.x + (Math.random() > 0.5 ? -200 : 200); this.y = p.y - 50; this.state = 'idle'; this.timer = 1.0; particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h / 2, count: 30, color: '#a0d2eb', speed: 200, size: 5, lifetime: 0.5, glow: true }); } }, 500); }
            iceShards(p, count = 5) { this.state = 'telegraph'; this.timer = 1.2; audio.playSound('skill_ice'); setTimeout(() => { if (this.hp > 0 && this.active) { this.state = 'idle'; this.timer = 1.5; for (let i = 0; i < count; i++) { setTimeout(() => { if (!this.active) return; const ang = Math.atan2(p.y - this.y, p.x - this.x); game.projectiles.push(new Projectile(this.x + this.w / 2, this.y + this.h / 2, ang, 400, 10, '#fff', 2.0)); }, i * 100); } } }, 1200); }
            iceClone() { this.state = 'telegraph'; this.timer = 0.8; setTimeout(() => { if (this.hp > 0 && this.active) { this.state = 'idle'; this.timer = 2.0; game.projectiles.push(new IceClone(this.x - 100, this.y, game.player)); } }, 800); }
            freezingCloud() { this.state = 'telegraph'; this.timer = 1.5; setTimeout(() => { if (this.hp > 0 && this.active) { this.state = 'idle'; this.timer = 3.0; screenEffects.shake(0.4, 10); particleManager.spawn({ x: GAME_WIDTH / 2, y: 600, count: 200, color: '#e0f7fa', speed: 50, size: 8, lifetime: 3, angle: -Math.PI / 2, spread: Math.PI / 4, gravity: -100, glow: true }); const attackInterval = setInterval(() => { if (!this.active || game.player.hp <= 0) { clearInterval(attackInterval); return; } if (game.player.onGround && game.currentRoom === this.room) game.player.takeDamage(5); }, 200); setTimeout(() => clearInterval(attackInterval), 3000); } }, 1500); }
            drawDetails(ctx) { ctx.fillStyle = '#f0e68c'; ctx.fillRect(this.x + 20, this.y - 12, this.w - 40, 14); }
        }
        class Kokushibo extends Boss {
            constructor(x, y) { super({ name: "Kokushibo, Upper Moon 1", maxHp: 250, startX: x, startY: y, w: 60, h: 90, color: '#4a148c', p2Color: '#7b1fa2', p3Color: '#9c27b0', particleColor: '#ce93d8' }); }
            updatePhases() {
                if (this.hp < this.maxHp * 0.7 && this.phase === 1) { this.phase = 2; this.state = 'transition'; this.timer = 1.5; screenEffects.shake(0.7, 18); }
                else if (this.hp < this.maxHp * 0.4 && this.phase === 2) { this.phase = 3; this.state = 'transition'; this.timer = 1.5; screenEffects.shake(1.0, 22); }
            }
            chooseAction(p) {
                let a = Math.random();
                if (this.phase === 1) { if (a < 0.7) this.moonSlash(p); else this.teleport(p); }
                else if (this.phase === 2) { if (a < 0.5) this.moonSlash(p, 3); else if (a < 0.8) this.multiSlash(p); else this.teleport(p); }
                else { if (a < 0.4) this.multiSlash(p); else if (a < 0.8) this.moonVortex(); else this.teleport(p); }
            }
            teleport(p) { this.state = 'telegraph'; this.timer = 0.3; particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h / 2, count: 20, color: this.particleColor, speed: 300, size: 4, lifetime: 0.3, glow: true }); setTimeout(() => { if (this.hp > 0 && this.active) { this.x = p.facing > 0 ? p.x - 150 : p.x + 150; this.y = p.y; this.state = 'idle'; this.timer = 0.5; particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h / 2, count: 20, color: this.particleColor, speed: 300, size: 4, lifetime: 0.3, glow: true }); } }, 300); }
            moonSlash(p, count = 1) { this.state = 'telegraph'; this.timer = 0.8; audio.playSound('skill_moon'); setTimeout(() => { if (this.hp > 0 && this.active) { this.state = 'idle'; this.timer = 1.2; for (let i = 0; i < count; i++) { setTimeout(() => { if (!this.active) return; const ang = Math.atan2(p.y - this.y, p.x - this.x); game.projectiles.push(new Projectile(this.x + this.w / 2, this.y + this.h / 2, ang, 600, 20, this.particleColor, 1.5, true)); }, i * 200); } } }, 800); }
            multiSlash(p) { this.state = 'telegraph'; this.timer = 1.0; setTimeout(() => { if (this.hp > 0 && this.active) { this.state = 'idle'; this.timer = 2.0; let ang = Math.atan2(p.y - this.y, p.x - this.x); for (let i = -2; i <= 2; i++) { game.projectiles.push(new Projectile(this.x + this.w / 2, this.y + this.h / 2, ang + i * 0.2, 500, 15, this.particleColor, 1.8, true)); } } }, 1000); }
            moonVortex() { this.state = 'telegraph'; this.timer = 1.2; setTimeout(() => { if (this.hp > 0 && this.active) { this.state = 'idle'; this.timer = 3.0; screenEffects.shake(0.8, 20); for (let i = 0; i < 16; i++) { game.projectiles.push(new Projectile(this.x + this.w / 2, this.y + this.h / 2, (i / 16) * Math.PI * 2, 400, 25, this.particleColor, 2.5, true)); } } }, 1200); }
            drawDetails(ctx) { ctx.fillStyle = '#212121'; ctx.fillRect(this.x + 15, this.y - 15, this.w - 30, 18); ctx.fillStyle = '#ffeb3b'; for (let i = 0; i < 3; i++) { ctx.fillRect(this.x + 10 + (i * 15), this.y + 10, 8, 8); ctx.fillRect(this.x + 10 + (i * 15), this.y + 25, 8, 8); } }
        }

        // ##################################################################
        // #                       PROJECTILES                            #
        // ##################################################################
        class Projectile {
            constructor(x, y, angle, speed, damage, color, lifetime, isCrescent = false) {
                Object.assign(this, { x, y, damage, color, lifetime, isCrescent, age: 0 });
                this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed;
            }
            update(dt) { this.x += this.vx * dt; this.y += this.vy * dt; this.age += dt; if (this.collidesWith(game.player)) { game.player.takeDamage(this.damage); this.lifetime = 0; } }
            isDead() { return this.age >= this.lifetime; }
            collidesWith(e) { return this.x > e.x && this.x < e.x + e.w && this.y > e.y && this.y < e.y + e.h; }
            draw(ctx) {
                ctx.save(); ctx.shadowColor = this.color; ctx.shadowBlur = 15; ctx.fillStyle = this.color;
                if (this.isCrescent) {
                    ctx.beginPath(); const angle = Math.atan2(this.vy, this.vx);
                    ctx.translate(this.x, this.y); ctx.rotate(angle); ctx.scale(1.5, 1);
                    ctx.arc(0, 0, 15, -Math.PI / 2, Math.PI / 2);
                    ctx.arc(0, 0, 10, Math.PI / 2, -Math.PI / 2, true);
                    ctx.closePath(); ctx.fill();
                } else {
                    ctx.beginPath(); ctx.arc(this.x, this.y, 8, 0, Math.PI * 2); ctx.fill();
                }
                ctx.restore();
            }
        }
        class IceClone extends Projectile {
            constructor(x, y, player) {
                super(x, y, 0, 0, 15, '#a0d2eb', 3.0);
                this.w = 70; this.h = 85; this.state = 'idle'; this.stateTimer = 1.0; this.target = player;
            }
            update(dt) {
                this.age += dt; this.stateTimer -= dt;
                if (this.stateTimer <= 0 && this.state === 'idle') {
                    this.state = 'attacking'; const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                    this.vx = Math.cos(angle) * 300; this.vy = Math.sin(angle) * 300; this.stateTimer = 0.5;
                }
                this.x += this.vx * dt; this.y += this.vy * dt;
                if (this.collidesWith(this.target)) { this.target.takeDamage(this.damage); this.lifetime = 0; }
            }
            collidesWith(e) { return this.x < e.x + e.w && this.x + this.w > e.x && this.y < e.y + e.h && this.y + this.h > e.y; }
            draw(ctx) {
                ctx.save(); ctx.globalAlpha = 0.6 * (1 - this.age / 3.0);
                ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.w, this.h);
                ctx.restore();
            }
        }

        // ##################################################################
        // #                         GAME LOGIC                           #
        // ##################################################################
        const game = {
            state: 'start', player: new Player(150, 500), camera: new Camera(GAME_WIDTH, GAME_HEIGHT),
            rooms: [], projectiles: [], currentRoomIndex: 0, hitStop: 0, bossesDefeated: 0,
            init() {
                this.rooms.push(new Room({ w: 1280, h: 720, tiles: [new Tile(0, 650, 1280, 70), new Tile(400, 500, 150, 20), new Tile(700, 400, 150, 20), new Tile(100, 300, 200, 20),], doors: [new Door(1200, 550, 80, 100, 1, 100, 550)], }));
                this.rooms.push(new Room({ w: 1280, h: 720, tiles: [new Tile(0, 650, 400, 70), new Tile(880, 650, 400, 70), new Tile(400, 650, 480, 16, 'spike'), new Tile(600, 500, 80, 20, 'moving_h'), new Tile(300, 350, 150, 20), new Tile(850, 350, 150, 20), new Tile(0, 0, 20, 720), new Tile(1260, 0, 20, 720),], doors: [new Door(0, 550, 80, 100, 0, 1100, 550), new Door(1200, 250, 80, 100, 2, 100, 550),], healingOrbs: [new HealingOrb(620, 450)] }));
                this.rooms.push(new Room({ w: 1280, h: 720, tiles: [new Tile(0, 650, 1280, 70), new Tile(0, 0, 20, 720), new Tile(1260, 0, 20, 720),], doors: [new Door(0, 550, 80, 100, 1, 1100, 250), new Door(1200, 550, 80, 100, 3, 100, 550, () => game.bossesDefeated < 1)], bosses: [new Akaza(900, 570)], hashira: new Giyu(200, 590) }));
                this.rooms.push(new Room({ w: 1280, h: 720, tiles: [new Tile(0, 650, 1280, 70), new Tile(0, 0, 20, 720), new Tile(1260, 0, 20, 720), new Tile(500, 450, 200, 20)], doors: [new Door(0, 550, 80, 100, 2, 1100, 550), new Door(1200, 550, 80, 100, 4, 100, 550)], healingOrbs: [new HealingOrb(580, 400)] }));
                this.rooms.push(new Room({ w: 1280, h: 720, tiles: [new Tile(0, 650, 1280, 70), new Tile(0, 0, 20, 720), new Tile(1260, 0, 20, 720)], doors: [new Door(0, 550, 80, 100, 3, 1100, 550), new Door(1200, 550, 80, 100, 5, 100, 550, () => game.bossesDefeated < 2)], bosses: [new Doma(900, 565)], hashira: new Shinobu(200, 585) }));
                this.rooms.push(new Room({ w: 1920, h: 720, tiles: [new Tile(0, 650, 1920, 70), new Tile(0, 0, 20, 720), new Tile(1900, 0, 20, 720), new Tile(300, 500, 100, 20, 'moving_h'), new Tile(600, 400, 150, 16, 'spike'), new Tile(600, 380, 150, 20), new Tile(900, 250, 100, 20, 'moving_v'), new Tile(1200, 400, 150, 20), new Tile(1500, 500, 100, 20, 'moving_h'),], doors: [new Door(0, 550, 80, 100, 4, 1100, 550), new Door(1820, 550, 80, 100, 6, 100, 560)], healingOrbs: [new HealingOrb(1000, 200)] }));
                this.rooms.push(new Room({ w: 1280, h: 720, tiles: [new Tile(0, 650, 1280, 70), new Tile(0, 0, 20, 720), new Tile(1260, 0, 20, 720),], bosses: [new Kokushibo(900, 560)], hashira: new Gyomei(200, 580) }));
                this.currentRoom = this.rooms[this.currentRoomIndex];
            },
            reset() {
                this.player.reset(150, 500); this.rooms.forEach(r => r.reset());
                this.projectiles = []; this.currentRoomIndex = 0;
                this.currentRoom = this.rooms[0]; this.bossesDefeated = 0;
            },
            setState(newState) {
                this.state = newState;
                document.getElementById('start-screen').style.display = (newState === 'start') ? 'flex' : 'none';
                document.getElementById('game-over-screen').style.display = (newState === 'gameOver') ? 'flex' : 'none';
                document.getElementById('victory-screen').style.display = (newState === 'victory') ? 'flex' : 'none';
            },
            startBossEncounter() {
                const boss = this.currentRoom.bosses.find(b => b.hp > 0);
                if (!boss) return;
                const hashira = this.currentRoom.hashira;
                let dialogueSequence = [];
                if (boss.name.includes("Akaza")) {
                    dialogueSequence = [{ speaker: "Akaza", text: "Your fighting spirit is weak. Why even bother showing up, Giyu?" }, { speaker: "Giyu Tomioka", text: "I am not like you. I protect others." }, { speaker: "Akaza", text: "Become a demon! We could fight for eternity!" }];
                } else if (boss.name.includes("Doma")) {
                    dialogueSequence = [{ speaker: "Doma", text: "Oh? Another little slayer? You're not nearly as cute as the last one I ate." }, { speaker: "Shinobu Kocho", text: "For my sister... I will see you perish where you stand." }, { speaker: "Doma", text: "Such anger! It's not very becoming of you." }];
                } else if (boss.name.includes("Kokushibo")) {
                    dialogueSequence = [{ speaker: "Kokushibo", text: "A swordsman and... a Pillar of stone. How unsightly." }, { speaker: "Gyomei Himejima", text: "May the Buddha have mercy on your pitiful soul." }, { speaker: "Kokushibo", text: "Your prayers are wasted. There is only the blade." }];
                }
                if (dialogueSequence.length > 0) {
                    this.state = 'dialogue';
                    dialogueManager.start(dialogueSequence);
                } else {
                    this.state = 'playing';
                }
                boss.activate();
                if (hashira) hashira.activate();
            },
            update(dt) {
                if (this.state === 'dialogue') { dialogueManager.update(dt); return; }
                if (this.hitStop > 0) { this.hitStop -= dt; return; }
                this.player.update(dt, this.currentRoom);
                this.currentRoom.update(dt);
                this.camera.follow(this.player, this.currentRoom);
                particleManager.update(dt);
                screenEffects.update(dt);
                for (let i = this.projectiles.length - 1; i >= 0; i--) { this.projectiles[i].update(dt); if (this.projectiles[i].isDead()) this.projectiles.splice(i, 1); }
                for (let i = this.currentRoom.healingOrbs.length - 1; i >= 0; i--) {
                    const orb = this.currentRoom.healingOrbs[i];
                    if (orb.active && this.player.x < orb.x + orb.w && this.player.x + this.player.w > orb.x && this.player.y < orb.y + orb.h && this.player.y + this.player.h > orb.y) {
                        orb.active = false; this.player.heal(50);
                    }
                }
                this.currentRoom.doors.forEach(d => {
                    if (this.player.x < d.x + d.w && this.player.x + this.player.w > d.x && this.player.y < d.y + d.h && this.player.y + this.player.h > d.y) {
                        if (d.isLocked()) return;
                        this.player.endAttack();
                        this.currentRoomIndex = d.toRoom;
                        this.currentRoom = this.rooms[this.currentRoomIndex];
                        this.player.x = d.entryX; this.player.y = d.entryY;
                        this.projectiles = [];
                        const bossToActivate = this.currentRoom.bosses.find(b => !b.active && b.hp > 0);
                        if (bossToActivate) { this.startBossEncounter(); }
                    }
                });
                keysToTrack.forEach(k => input[k + 'Pressed'] = false);
            },
            checkPlayerAttack(x, y, w, h, damage = 10) {
                this.currentRoom.bosses.forEach(b => {
                    if (b.active && x < b.x + b.w && x + w > b.x && y < b.y + b.h && y + h > b.y) {
                        b.takeDamage(damage);
                    }
                });
            },
            checkHashiraAttack(x, y, w, h, damage = 10, color = '#FFFFFF') {
                particleManager.spawn({ x: x + w / 2, y: y + h / 2, count: 15, color: color, speed: 100, size: 4, lifetime: 0.4 });
                this.currentRoom.bosses.forEach(b => {
                    if (b.active && x < b.x + b.w && x + w > b.x && y < b.y + b.h && y + h > b.y) {
                        b.takeDamage(damage);
                    }
                });
            },
            bossDefeated() {
                this.bossesDefeated++;
                this.player.heal(this.player.maxHp);
                if (this.bossesDefeated >= 3) { this.setState('victory'); }
            },
            draw() {
                ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                this.camera.apply(ctx);
                this.currentRoom.draw(ctx, this.camera);
                this.projectiles.forEach(p => p.draw(ctx));
                this.player.draw(ctx);
                particleManager.draw(ctx);
                this.camera.release(ctx);
                this.updateUI();
            },
            updateUI() {
                document.getElementById('hp-bar-inner').style.width = `${Math.max(0, this.player.hp / this.player.maxHp * 100)}%`;
                document.getElementById('focus-bar-inner').style.width = `${Math.max(0, this.player.focus / this.player.maxFocus * 100)}%`;
                const styleName = this.player.currentStyle === 0 ? "Water Breathing" : "Hinokami Kagura";
                document.getElementById('style-indicator').textContent = styleName;
                const currentSkills = this.player.skills[this.player.currentStyle];
                document.getElementById('skillF-cooldown').style.height = `${Math.max(0, currentSkills['F'].cooldown / currentSkills['F'].maxCooldown * 100)}%`;
                document.getElementById('skillX-cooldown').style.height = `${Math.max(0, currentSkills['X'].cooldown / currentSkills['X'].maxCooldown * 100)}%`;
                document.getElementById('skill1-cooldown').style.height = `${Math.max(0, currentSkills['1'].cooldown / currentSkills['1'].maxCooldown * 100)}%`;
                document.getElementById('skill2-cooldown').style.height = `${Math.max(0, currentSkills['2'].cooldown / currentSkills['2'].maxCooldown * 100)}%`;
                document.getElementById('skill3-cooldown').style.height = `${Math.max(0, currentSkills['3'].cooldown / currentSkills['3'].maxCooldown * 100)}%`;
                const bossBar = document.getElementById('boss-hud');
                const activeBoss = this.currentRoom.getActiveBoss();
                if (activeBoss) {
                    bossBar.style.opacity = '1';
                    document.getElementById('boss-name').textContent = activeBoss.name;
                    document.getElementById('boss-hp-bar-inner').style.width = `${Math.max(0, activeBoss.hp / activeBoss.maxHp * 100)}%`;
                    document.getElementById('boss-status-icon').textContent = activeBoss.poisonTimer > 0 ? '' : '';
                } else {
                    bossBar.style.opacity = '0';
                }
                const hashiraHud = document.getElementById('hashira-hud');
                const activeHashira = this.currentRoom.hashira;
                if (activeHashira && activeHashira.active) {
                    hashiraHud.style.opacity = '1';
                    document.getElementById('hashira-name').textContent = activeHashira.name;
                    document.getElementById('hashira-state').textContent = `State: ${activeHashira.state.toUpperCase()}`;
                } else {
                    hashiraHud.style.opacity = '0';
                }
            },
        };

        // ##################################################################
        // #                         MAIN LOOP                            #
        // ##################################################################
        let lastTime = 0;
        function loop(timestamp) {
            const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
            lastTime = timestamp;
            if (game.state === 'playing' || game.state === 'dialogue') {
                game.update(dt);
            }
            game.draw();
            requestAnimationFrame(loop);
        }
        document.getElementById('start-screen').addEventListener('click', () => {
            audio.init(); game.reset(); game.setState('playing');
            lastTime = performance.now();
        });
        document.getElementById('game-over-screen').addEventListener('click', () => {
            game.reset(); game.setState('playing');
        });
        document.getElementById('victory-screen').addEventListener('click', () => {
            game.reset(); game.setState('playing');
        });
        game.init();
        requestAnimationFrame(loop);
    </script>
</body>

</html>