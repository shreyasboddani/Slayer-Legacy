<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Demon Slayer: Final Confrontation</title>
    <meta name="description"
        content="An evolved 2D Demon Slayer game featuring Hashira assists, dialogue, and advanced combat mechanics.">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+JP:wght@400;700&display=swap');

        html,
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            color: #fff;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-family: 'Noto Serif JP', serif;
        }

        canvas {
            background-color: #0a0814;
            image-rendering: pixelated;
            /* Ensures pixel art doesn't look blurry */
            border: 3px solid #302a4d;
            box-shadow: 0 0 15px #c386f1, 0 0 45px #c386f1, inset 0 0 20px rgba(0, 0, 0, 0.5);
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .hud-bar {
            position: absolute;
            top: 20px;
            background: rgba(10, 8, 20, 0.7);
            border: 1px solid #302a4d;
            border-radius: 5px;
            overflow: hidden;
            padding: 2px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .bar-inner {
            height: 20px;
            border-radius: 3px;
            transition: width 0.2s ease-out;
        }

        #hp-bar {
            left: 20px;
            width: 250px;
        }

        #hp-bar-inner {
            background: linear-gradient(90deg, #e53935, #b71c1c);
        }

        #focus-bar {
            left: 20px;
            top: 50px;
            width: 200px;
        }

        #focus-bar-inner {
            background: linear-gradient(90deg, #42a5f5, #1976d2);
        }

        #boss-hud {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            opacity: 0;
            transition: opacity 0.5s;
            text-align: center;
        }

        #boss-name {
            font-size: 18px;
            text-shadow: 0 0 8px #000;
            margin-bottom: 5px;
        }

        #boss-hp-bar {
            position: relative;
            left: auto;
            top: auto;
            transform: none;
            width: 100%;
        }

        #boss-hp-bar-inner {
            background: linear-gradient(90deg, #d81b60, #880e4f);
        }

        #boss-status-icon {
            position: absolute;
            right: -30px;
            top: 5px;
            font-size: 20px;
        }

        #skill-hud {
            position: absolute;
            left: 20px;
            top: 80px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        #style-indicator {
            font-size: 16px;
            margin-bottom: 5px;
            text-shadow: 0 0 8px #fff;
        }

        .skill-container {
            display: flex;
            gap: 10px;
        }

        .skill-icon {
            width: 40px;
            height: 40px;
            background: rgba(10, 8, 20, 0.7);
            border: 1px solid #302a4d;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .cooldown-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(0, 0, 0, 0.8);
            transition: height 0.1s linear;
        }

        #hashira-hud {
            position: absolute;
            right: 20px;
            top: 20px;
            background: rgba(10, 8, 20, 0.7);
            border: 1px solid #302a4d;
            padding: 8px;
            border-radius: 5px;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }

        #hashira-name {
            font-size: 14px;
            margin-bottom: 4px;
        }

        #hashira-state {
            font-size: 12px;
            color: #ccc;
        }

        #dialogue-box {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 800px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #302a4d;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 0 20px #c386f1;
            z-index: 20;
            display: none;
            pointer-events: all;
            cursor: pointer;
        }

        #speaker-name {
            font-size: 22px;
            color: #c386f1;
            margin-bottom: 10px;
        }

        #dialogue-text {
            font-size: 18px;
            line-height: 1.5;
        }

        .game-screen {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 10;
            text-align: center;
            backdrop-filter: blur(5px);
        }

        .game-screen h1 {
            font-size: 48px;
            text-shadow: 0 0 15px #c386f1;
        }

        .game-screen p {
            font-size: 20px;
            margin-top: -10px;
        }

        .game-screen .controls {
            font-size: 16px;
            margin-top: 40px;
            line-height: 1.8;
            color: #ccc;
        }
    </style>
</head>

<body>
    <canvas id="gameCanvas"></canvas>
    <div id="ui-overlay">
        <div id="hp-bar" class="hud-bar">
            <div id="hp-bar-inner" class="bar-inner"></div>
        </div>
        <div id="focus-bar" class="hud-bar">
            <div id="focus-bar-inner" class="bar-inner"></div>
        </div>

        <div id="boss-hud">
            <div id="boss-name"></div>
            <div id="boss-hp-bar" class="hud-bar">
                <div id="boss-hp-bar-inner" class="bar-inner"></div>
                <div id="boss-status-icon"></div>
            </div>
        </div>

        <div id="skill-hud">
            <div id="style-indicator">Water Breathing</div>
            <div class="skill-container">
                <div class="skill-icon">F<div id="skillF-cooldown" class="cooldown-overlay"></div>
                </div>
                <div class="skill-icon">X<div id="skillX-cooldown" class="cooldown-overlay"></div>
                </div>
                <div class="skill-icon">1<div id="skill1-cooldown" class="cooldown-overlay"></div>
                </div>
                <div class="skill-icon">2<div id="skill2-cooldown" class="cooldown-overlay"></div>
                </div>
                <div class="skill-icon">3<div id="skill3-cooldown" class="cooldown-overlay"></div>
                </div>
            </div>
        </div>

        <div id="hashira-hud">
            <div id="hashira-name"></div>
            <div id="hashira-state"></div>
        </div>
    </div>

    <div id="dialogue-box">
        <div id="speaker-name"></div>
        <div id="dialogue-text"></div>
    </div>

    <div id="start-screen" class="game-screen">
        <h1>Demon Slayer: Final Confrontation</h1>
        <p>Press Space to Begin</p>
        <div class="controls">
            [A][D] - Move | [W] - Jump/Double Jump | [Q] - Dash<br>
            [C] - Switch Breathing Style | [F] - Parry | Mouse Click - Basic Attack | [1][2][3] - Special Attacks
        </div>
    </div>
    <div id="game-over-screen" class="game-screen" style="display: none;">
        <h1>You Have Fallen</h1>
        <p>Press Space to Restart</p>
    </div>
    <div id="victory-screen" class="game-screen" style="display: none;">
        <h1>Victory</h1>
        <p>You have defeated the Upper Moons!</p>
        <div class="controls">Press Space to Play Again</div>
    </div>

    <!-- Pause / Settings / Breathing Selector UI -->
    <div id="pause-overlay" class="game-screen" style="display:none; z-index: 30;">
        <h1>Paused</h1>
        <div style="margin-top:20px;">
            <button id="resume-btn">Resume</button>
            <button id="restart-btn">Restart</button>
        </div>
        <div style="margin-top:20px;">
            <label>Music: <input id="music-slider" type="range" min="0" max="1" step="0.01" value="0.6"></label><br>
            <label>SFX: <input id="sfx-slider" type="range" min="0" max="1" step="0.01" value="0.8"></label><br>
            <label>Graphics Quality: <input id="quality-slider" type="range" min="0.4" max="1" step="0.05"
                    value="1"></label>
        </div>
    </div>

    <div id="breathing-selector"
        style="position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); pointer-events:none; display:none; z-index:40;">
        <div
            style="width:280px; height:280px; border-radius:50%; background:radial-gradient(circle at 40% 30%, rgba(255,255,255,0.04), rgba(0,0,0,0.6)); box-shadow:0 0 40px rgba(0,0,0,0.6); display:flex; align-items:center; justify-content:center; color:#fff; font-family: sans-serif;">
            <div style="text-align:center; pointer-events:none;">
                <div style="font-size:18px; margin-bottom:8px;">Select Breathing</div>
                <div style="display:flex; gap:8px; justify-content:center;">
                    <div data-style="0" class="bs-item"
                        style="width:56px;height:56px;border-radius:8px;background:#42a5f5;display:flex;align-items:center;justify-content:center;">
                        Water</div>
                    <div data-style="1" class="bs-item"
                        style="width:56px;height:56px;border-radius:8px;background:#ff7043;display:flex;align-items:center;justify-content:center;">
                        Fire</div>
                    <div data-style="2" class="bs-item"
                        style="width:56px;height:56px;border-radius:8px;background:#bfefff;display:flex;align-items:center;justify-content:center;">
                        Wind</div>
                    <div data-style="3" class="bs-item"
                        style="width:56px;height:56px;border-radius:8px;background:#a1887f;display:flex;align-items:center;justify-content:center;">
                        Stone</div>
                </div>
                <div style="font-size:12px;margin-top:10px;opacity:0.9;">Release Q to select</div>
            </div>
        </div>
    </div>

    <script>
        // ##################################################################
        // #                            SETUP                             #
        // ##################################################################
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const GAME_WIDTH = 1280;
        const GAME_HEIGHT = 720;
        canvas.width = GAME_WIDTH;
        canvas.height = GAME_HEIGHT;

        // ##################################################################
        // #                        ASSET MANAGER                         #
        // ##################################################################
        const assetManager = {
            images: {},
            queue: [],
            successCount: 0,
            errorCount: 0,

            queueDownload(alias, path) {
                this.queue.push({ alias, path });
            },

            downloadAll(callback) {
                if (this.queue.length === 0) {
                    callback();
                    return;
                }
                for (let i = 0; i < this.queue.length; i++) {
                    const { alias, path } = this.queue[i];

                    if (this.images[alias]) {
                        this.successCount++;
                        if (this.isDone()) callback();
                        continue;
                    }
                    const img = new Image();
                    img.addEventListener("load", () => {
                        this.successCount++;
                        if (this.isDone()) {
                            callback();
                        }
                    });
                    img.addEventListener("error", () => {

                        try { delete this.images[alias]; } catch (e) { }
                        this.errorCount++;
                        console.warn(`Failed to load image at path: ${path}. Using built-in shape renderer fallback. To restore original sprites, place your sprite files at the listed paths (e.g. ${path}).`);
                        if (this.isDone()) {

                            callback();
                        }
                    });
                    img.src = path;
                    this.images[alias] = img;
                }
            },

            isDone() {
                return (this.queue.length === this.successCount + this.errorCount);
            },

            getAsset(alias) {
                return this.images[alias];
            }
        };

        // ##################################################################
        // #                           SYSTEMS                            #
        // ##################################################################

        // --- Sprite Animator (sprite sheet-based animation helper)
        class SpriteAnimator {
            constructor(image, frameWidth, frameHeight, animations = {}) {
                this.image = image; this.fw = frameWidth; this.fh = frameHeight; this.animations = animations;
                this.current = null; this.currentTime = 0; this.frameIndex = 0; this.loop = true;
            }
            play(name, loop = true) {
                if (!this.animations[name]) return; if (this.current !== name) { this.current = name; this.currentTime = 0; this.frameIndex = 0; this.loop = loop; }
            }
            update(dt) {
                if (!this.current) return; const anim = this.animations[this.current]; this.currentTime += dt * 1000; while (this.currentTime >= anim.frames[this.frameIndex].duration) { this.currentTime -= anim.frames[this.frameIndex].duration; this.frameIndex++; if (this.frameIndex >= anim.frames.length) { if (this.loop) this.frameIndex = 0; else { this.frameIndex = anim.frames.length - 1; } } }
            }
            draw(ctx, x, y, scale = 1, flip = false) {
                if (!this.current) return; const anim = this.animations[this.current]; const f = anim.frames[this.frameIndex]; const sx = f.x * this.fw, sy = f.y * this.fh;
                ctx.save(); if (flip) { ctx.scale(-1, 1); ctx.drawImage(this.image, sx, sy, this.fw, this.fh, -x - this.fw * scale, y, this.fw * scale, this.fh * scale); } else { ctx.drawImage(this.image, sx, sy, this.fw, this.fh, x, y, this.fw * scale, this.fh * scale); } ctx.restore();
            }
        }


        const spriteAnimators = {};

        // --- Save Manager (localStorage) ---
        const SaveManager = {
            key: 'slayer_legacy_save_v1',
            save(data) { try { localStorage.setItem(this.key, JSON.stringify(data)); } catch (e) { console.warn('Save failed', e); } },
            load() { try { const raw = localStorage.getItem(this.key); return raw ? JSON.parse(raw) : null; } catch (e) { console.warn('Load failed', e); return null; } },
            clear() { localStorage.removeItem(this.key); }
        };

        // --- Pause / Settings handlers ---
        const pauseOverlay = document.getElementById('pause-overlay');
        const resumeBtn = document.getElementById('resume-btn');
        const restartBtn = document.getElementById('restart-btn');
        const musicSlider = document.getElementById('music-slider');
        const sfxSlider = document.getElementById('sfx-slider');
        const qualitySlider = document.getElementById('quality-slider');
        let isPaused = false;
        function openPause() { isPaused = true; pauseOverlay.style.display = 'flex'; game.setState('paused'); }
        function closePause() { isPaused = false; pauseOverlay.style.display = 'none'; game.setState('playing'); lastTime = performance.now(); }
        resumeBtn.addEventListener('click', () => closePause());
        restartBtn.addEventListener('click', () => { game.reset(); closePause(); });
        qualitySlider.addEventListener('input', () => { perfOverlay.quality = Number(qualitySlider.value); particleManager.particleScale = perfOverlay.quality; particleManager.maxParticles = Math.round(800 * perfOverlay.quality); });

        // --- Breathing selector logic ---

        const breathingSelector = document.getElementById('breathing-selector');
        let selectedStyle = 0;

        breathingSelector.style.pointerEvents = 'auto';
        function updateBreathingUI() {
            const bsItems = document.querySelectorAll('#breathing-selector .bs-item');
            let current = selectedStyle;
            try {

                if (game && game.player) current = game.player.currentStyle;
            } catch (e) {

            }
            bsItems.forEach(it => {
                if (Number(it.dataset.style) === current) it.style.outline = '2px solid #fff';
                else it.style.outline = '';
            });
        }
        document.querySelectorAll('#breathing-selector .bs-item').forEach(el => {
            el.addEventListener('mouseenter', () => { el.style.transform = 'scale(1.06)'; });
            el.addEventListener('mouseleave', () => { el.style.transform = 'scale(1)'; });
            el.addEventListener('click', () => {
                const s = Number(el.dataset.style);
                selectedStyle = s;
                try {
                    if (game && game.player) game.player.currentStyle = s;
                } catch (e) {

                }
                updateBreathingUI();
            });
        });

        updateBreathingUI();


        // --- Audio Engine ---
        const audio = {
            ctx: null,
            init() { if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); },
            playSound(type, volume = 0.5, duration = 0.1) {
                if (!this.ctx) return;
                const o = this.ctx.createOscillator();
                const g = this.ctx.createGain();
                g.gain.setValueAtTime(volume, this.ctx.currentTime);
                g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
                let freq = 100, wave = 'triangle';
                switch (type) {
                    case 'jump': freq = 440; break;
                    case 'slash': freq = 220; g.gain.setValueAtTime(volume * 0.5, this.ctx.currentTime); wave = 'square'; break;
                    case 'dash': freq = 880; duration = 0.15; break;
                    case 'hit_player': freq = 150; duration = 0.2; break;
                    case 'hit_enemy': freq = 300; wave = 'square'; break;
                    case 'skill_water': freq = 600; duration = 0.4; break;
                    case 'skill_fire': freq = 250; duration = 0.5; wave = 'sawtooth'; break;
                    case 'skill_ice': freq = 700; duration = 0.6; wave = 'sine'; break;
                    case 'skill_moon': freq = 180; duration = 0.7; wave = 'sawtooth'; break;
                    case 'skill_wind': freq = 900; duration = 0.35; wave = 'triangle'; break;
                    case 'skill_stone': freq = 160; duration = 0.8; wave = 'sine'; break;
                    case 'switch_style': freq = 1000; duration = 0.05; break;
                    case 'heal': freq = 800; wave = 'sine'; duration = 0.3; break;
                    case 'parry_success': freq = 1200; wave = 'sine'; duration = 0.2; break;
                    case 'parry_fail': freq = 100; wave = 'square'; duration = 0.1; break;
                }
                o.type = wave;
                o.frequency.setValueAtTime(freq, this.ctx.currentTime);
                o.connect(g);
                g.connect(this.ctx.destination);
                o.start(this.ctx.currentTime);
                o.stop(this.ctx.currentTime + duration);
            }
        };

        // --- Input Handler ---
        const input = { left: false, right: false, jump: false, dash: false, attack: false, skill1: false, skill2: false, skill3: false, switchStyle: false, parry: false };
        const keysToTrack = ['jump', 'dash', 'attack', 'skill1', 'skill2', 'skill3', 'switchStyle', 'parry'];
        keysToTrack.forEach(key => input[key + 'Pressed'] = false);
        window.addEventListener('keydown', handleKeyEvent);
        window.addEventListener('keyup', handleKeyEvent);

        window.addEventListener('mousedown', (e) => {
            if (e.button === 0) {
                if (!input.attack) input.attackPressed = true;
                input.attack = true;
            }
        });
        window.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                input.attack = false;
            }
        });
        function handleKeyEvent(e) {
            if (dialogueManager.isActive) return;
            const state = e.type === 'keydown';

            if (e.code === 'Space' || e.key === ' ' || e.key === 'Spacebar') {
                if (state && !input.jump) input.jumpPressed = true;
                input.jump = state;
                return;
            }
            switch (e.code) {
                case 'KeyA': case 'ArrowLeft': input.left = state; break;
                case 'KeyD': case 'ArrowRight': input.right = state; break;
                case 'KeyW': case 'ArrowUp': if (state && !input.jump) input.jumpPressed = true; input.jump = state; break;
                case 'KeyQ':
                    if (state && !input.dash) input.dashPressed = true; input.dash = state; break;

                case 'KeyX': if (state && !input.attack) input.attackPressed = true; input.attack = state; break;
                case 'Digit1': if (state && !input.skill1) input.skill1Pressed = true; input.skill1 = state; break;
                case 'Digit2': if (state && !input.skill2) input.skill2Pressed = true; input.skill2 = state; break;
                case 'Digit3': if (state && !input.skill3) input.skill3Pressed = true; input.skill3 = state; break;
                case 'KeyF': if (state && !input.parry) input.parryPressed = true; input.parry = state; break;
            }
        }


        window.addEventListener('keydown', (e) => {
            if (e.code === 'KeyC' && !dialogueManager.isActive) {

                breathingSelector.style.display = 'block';
                setTimeout(() => { breathingSelector.style.display = 'none'; }, 1200);

                try {
                    if (game && game.player) {
                        game.player.currentStyle = (game.player.currentStyle + 1) % game.player.skills.length;
                        audio.playSound('switch_style');
                        updateBreathingUI();
                        particleManager.spawn({ x: game.player.x + game.player.w / 2, y: game.player.y + game.player.h / 2, count: 25, color: game.player.currentStyle === 0 ? '#42a5f5' : '#ff7043', speed: 100, size: 4, lifetime: 0.5, glow: true });
                    }
                } catch (err) { }
            }
        });

        // --- Particle Engine ---
        class Particle {
            constructor(config) { Object.assign(this, { age: 0, ...config }); }
            update(dt) { this.vx *= this.drag || 0.99; this.vy *= this.drag || 0.99; this.vy += this.gravity * dt; this.x += this.vx * dt; this.y += this.vy * dt; this.age += dt; if (this.size > 0.1) this.size *= this.shrink || 0.97; }
            draw(ctx) {
                ctx.globalAlpha = 1 - (this.age / this.lifetime);
                if (this.glow) { ctx.shadowColor = this.color; ctx.shadowBlur = this.size * 1.5; }
                ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
                ctx.shadowBlur = 0; ctx.globalAlpha = 1;
            }
            isDead() { return this.age >= this.lifetime || this.size < 0.2; }
        }
        const particleManager = {
            particles: [],
            maxParticles: 800,
            particleScale: 1,
            spawn(config) {
                const { x, y, count, color, speed, size, lifetime, angle = 0, spread = Math.PI * 2, gravity = 0, ...rest } = config;

                const allowed = Math.max(0, this.maxParticles - this.particles.length);
                const toSpawn = Math.min(count, allowed);
                if (toSpawn <= 0) return;
                for (let i = 0; i < toSpawn; i++) {
                    const currentAngle = angle - spread / 2 + Math.random() * spread;
                    const currentSpeed = (typeof speed === 'number') ? Math.random() * speed : speed[0] + Math.random() * (speed[1] - speed[0]);
                    const vx = Math.cos(currentAngle) * currentSpeed; const vy = Math.sin(currentAngle) * currentSpeed;
                    const pSize = (typeof size === 'number') ? Math.random() * size + 1 : size[0] + Math.random() * (size[1] - size[0]);
                    this.particles.push(new Particle({ x, y, vx, vy, size: pSize * this.particleScale, color, lifetime: Math.random() * lifetime + 0.2, gravity, ...rest }));
                }
            },
            update(dt) { for (let i = this.particles.length - 1; i >= 0; i--) { this.particles[i].update(dt); if (this.particles[i].isDead()) this.particles.splice(i, 1); } },
            draw(ctx) { this.particles.forEach(p => p.draw(ctx)); }
        };

        // --- Visual helpers ---
        function drawTelegraphRing(ctx, x, y, radius, color, progress) {
            ctx.save();
            ctx.globalAlpha = 0.6 * (1 - progress);
            ctx.lineWidth = 6;
            ctx.strokeStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, radius * (0.6 + progress * 0.8), 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }

        // --- Debug / Performance overlay ---
        const perfOverlay = {
            fps: 60, last: performance.now(), frames: 0, lastSample: performance.now(), quality: 1.0, update() {
                this.frames++;
                const now = performance.now();
                if (now - this.lastSample > 500) {
                    this.fps = Math.round((this.frames * 1000) / (now - this.lastSample));
                    this.frames = 0; this.lastSample = now;

                    if (this.fps < 40) this.quality = Math.max(0.4, this.quality - 0.1);
                    else if (this.fps > 55) this.quality = Math.min(1.0, this.quality + 0.05);
                    particleManager.particleScale = this.quality;
                    particleManager.maxParticles = Math.round(800 * this.quality);
                }
            }, draw(ctx) { ctx.save(); ctx.fillStyle = 'rgba(0,0,0,0.4)'; ctx.fillRect(10, 10, 120, 40); ctx.fillStyle = '#fff'; ctx.font = '14px sans-serif'; ctx.fillText(`FPS: ${this.fps}`, 18, 28); ctx.fillText(`Q: ${Math.round(this.quality * 100)}%`, 18, 44); ctx.restore(); }
        };

        // --- Dialogue Manager ---
        const dialogueManager = {
            isActive: false, sequence: [], currentIndex: 0, currentText: '', charIndex: 0,
            dialogueBox: document.getElementById('dialogue-box'),
            speakerName: document.getElementById('speaker-name'),
            dialogueText: document.getElementById('dialogue-text'),
            start(sequence) {
                this.sequence = sequence; this.isActive = true; this.currentIndex = 0;
                this.dialogueBox.style.display = 'block'; this.loadMessage();
                this.dialogueBox.onclick = () => this.next();
            },
            loadMessage() {
                if (this.currentIndex >= this.sequence.length) { this.end(); return; }
                const msg = this.sequence[this.currentIndex];
                this.speakerName.textContent = msg.speaker; this.dialogueText.textContent = '';
                this.currentText = msg.text; this.charIndex = 0;
            },
            update(dt) {
                if (!this.isActive || this.charIndex >= this.currentText.length) return;
                this.charIndex += 50 * dt;
                this.dialogueText.textContent = this.currentText.substring(0, Math.floor(this.charIndex));
            },
            next() {
                if (this.charIndex < this.currentText.length) {
                    this.charIndex = this.currentText.length;
                    this.dialogueText.textContent = this.currentText;
                } else {
                    this.currentIndex++; this.loadMessage();
                }
            },
            end() {
                this.isActive = false; this.dialogueBox.style.display = 'none';
                this.dialogueBox.onclick = null; game.state = 'playing';
                console.log('Dialogue ended — state set to', game.state);
            }
        };

        // --- Screen Effects ---
        const screenEffects = {
            shakeTimer: 0, intensity: 0,
            shake(duration, intensity) { this.shakeTimer = Math.max(this.shakeTimer, duration); this.intensity = Math.max(this.intensity, intensity); },
            update(dt) { if (this.shakeTimer > 0) { this.shakeTimer -= dt; if (this.shakeTimer <= 0) this.intensity = 0; } },
            apply(ctx) { if (this.shakeTimer > 0) { ctx.translate((Math.random() - 0.5) * this.intensity, (Math.random() - 0.5) * this.intensity); } }
        };

        // --- Camera ---
        class Camera {
            constructor(w, h) { this.x = 0; this.y = 0; this.width = w; this.height = h; this.smoothSpeed = 0.08; }
            follow(target, level) {
                let tX = target.x + target.w / 2 - this.width / 2; let tY = target.y + target.h / 2 - this.height / 2;
                this.x += (tX - this.x) * this.smoothSpeed; this.y += (tY - this.y) * this.smoothSpeed;
                this.x = Math.max(0, Math.min(this.x, level.w - this.width)); this.y = Math.max(0, Math.min(this.y, level.h - this.height));
            }
            apply(ctx) { ctx.save(); screenEffects.apply(ctx); ctx.translate(-this.x, -this.y); }
            release(ctx) { ctx.restore(); }
        }

        // ##################################################################
        // #                        WORLD & MAP                           #
        // ##################################################################
        class HealingOrb {
            constructor(x, y) { this.x = x; this.y = y; this.w = 24; this.h = 24; this.active = true; this.bobOffset = 0; this.bobSpeed = 2; }
            update(dt) { this.bobOffset = Math.sin(performance.now() / 1000 * this.bobSpeed) * 5; }
            draw(ctx) {
                if (!this.active) return;
                ctx.save(); ctx.shadowColor = '#4caf50'; ctx.shadowBlur = 20;
                ctx.fillStyle = 'rgba(76, 175, 80, 0.3)';
                ctx.beginPath(); ctx.arc(this.x + this.w / 2, this.y + this.h / 2 + this.bobOffset, this.w, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#81c784';
                ctx.beginPath(); ctx.arc(this.x + this.w / 2, this.y + this.h / 2 + this.bobOffset, this.w / 2, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
            }
        }

        class InfinityCastleBackground {
            constructor() {
                this.layers = {
                    far: { structures: [], depth: 0.1 },
                    mid: { structures: [], depth: 0.2 },
                    near: { structures: [], depth: 0.5 }
                };
                this.generateStructures();
            }

            generateStructures() {
                const worldWidth = 4000;
                const worldHeight = 3000;


                for (let i = 0; i < 40; i++) {
                    this.layers.far.structures.push({
                        x: Math.random() * worldWidth - worldWidth / 2,
                        y: Math.random() * worldHeight - worldHeight / 2,
                        w: Math.random() * 400 + 200,
                        h: Math.random() * 20 + 10,
                        color: `rgba(40, 30, 30, ${Math.random() * 0.3 + 0.2})`,
                        hasLantern: Math.random() > 0.8
                    });
                }


                for (let i = 0; i < 25; i++) {
                    this.layers.mid.structures.push({
                        x: Math.random() * worldWidth - worldWidth / 2,
                        y: Math.random() * worldHeight - worldHeight / 2,
                        w: Math.random() * 300 + 150,
                        h: Math.random() * 30 + 15,
                        color: 'rgba(30, 20, 20, 0.6)',
                        hasLantern: Math.random() > 0.6
                    });
                }


                for (let i = 0; i < 15; i++) {
                    this.layers.near.structures.push({
                        x: Math.random() * worldWidth - worldWidth / 2,
                        y: Math.random() * worldHeight - worldHeight / 2,
                        w: Math.random() * 500 + 300,
                        h: Math.random() * 40 + 20,
                        color: 'rgba(20, 10, 10, 0.8)',
                        hasLantern: Math.random() > 0.5
                    });
                }
            }

            draw(ctx, camera) {

                const grad = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
                grad.addColorStop(0, '#1a0802');
                grad.addColorStop(1, '#4d2412');
                ctx.save();
                ctx.fillStyle = grad;
                ctx.fillRect(camera.x, camera.y, camera.width, camera.height);
                ctx.restore();

                ctx.save();
                for (const layerName in this.layers) {
                    const layer = this.layers[layerName];
                    layer.structures.forEach(s => {
                        const parallaxX = camera.x * layer.depth;
                        const parallaxY = camera.y * layer.depth;

                        ctx.fillStyle = s.color;
                        ctx.fillRect(s.x - parallaxX, s.y - parallaxY, s.w, s.h);

                        if (s.hasLantern) {
                            const lanternX = s.x - parallaxX + (Math.random() * s.w * 0.8) + (s.w * 0.1);
                            const lanternY = s.y - parallaxY + s.h / 2 - 5;
                            ctx.fillStyle = `rgba(255, 180, 80, 0.8)`;
                            ctx.shadowColor = '#ffb450';
                            ctx.shadowBlur = 15;
                            ctx.fillRect(lanternX, lanternY, 10, 10);
                        }
                    });
                }
                ctx.restore();
            }
        }

        class Tile {
            constructor(x, y, w, h, type = 'solid') {
                Object.assign(this, { x, y, w, h, type, initialX: x, initialY: y });
                if (type === 'moving_h') this.vx = 70;
                if (type === 'moving_v') this.vy = 70;
            }
            update(dt) {
                if (this.type === 'moving_h') { this.x += this.vx * dt; if (Math.abs(this.x - this.initialX) > 150) this.vx *= -1; }
                if (this.type === 'moving_v') { this.y += this.vy * dt; if (Math.abs(this.y - this.initialY) > 100) this.vy *= -1; }
            }
            draw(ctx) {

                if (this.type === 'spike') {
                    ctx.fillStyle = '#ff4d4d'; ctx.beginPath();
                    for (let i = 0; i < this.w / 16; i++) { ctx.moveTo(this.x + i * 16, this.y + 16); ctx.lineTo(this.x + i * 16 + 8, this.y); ctx.lineTo(this.x + i * 16 + 16, this.y + 16); }
                    ctx.closePath(); ctx.fill();
                    return;
                }


                const gradient = ctx.createLinearGradient(this.x, this.y, this.x, this.y + this.h);
                gradient.addColorStop(0, '#5a5278');
                gradient.addColorStop(1, '#302a4d');
                ctx.fillStyle = gradient;
                ctx.fillRect(this.x, this.y, this.w, this.h);
            }
        }
        class Door {
            constructor(x, y, w, h, to, eX, eY, lockedCondition = () => false) { Object.assign(this, { x, y, w, h, toRoom: to, entryX: eX, entryY: eY, lockedCondition }); }
            isLocked() { return this.lockedCondition(); }
            draw(ctx) {
                if (this.isLocked()) {
                    ctx.fillStyle = 'rgba(255, 50, 50, 0.4)'; ctx.strokeStyle = '#ff0000'; ctx.lineWidth = 2;
                    ctx.fillRect(this.x, this.y, this.w, this.h); ctx.strokeRect(this.x, this.y, this.w, this.h);
                } else {
                    ctx.fillStyle = 'rgba(255, 223, 186, 0.4)'; ctx.fillRect(this.x, this.y, this.w, this.h);
                }
            }
        }
        class Room {
            constructor(c) {
                Object.assign(this, { tiles: [], doors: [], bosses: [], healingOrbs: [], hashira: null, background: new InfinityCastleBackground(), ...c });
                this.bosses.forEach(b => b.room = this);
                if (this.hashira) this.hashira.room = this;
            }
            update(dt) {
                this.tiles.forEach(t => t.update(dt));
                this.healingOrbs.forEach(o => o.update(dt));

                for (let i = 0; i < this.bosses.length; i++) {
                    const b = this.bosses[i];
                    if (!b || !b.active) continue;
                    try {
                        b.update(dt, game.player);
                    } catch (e) {
                        console.error('Error updating boss', b && b.name, e);

                        try { b.active = false; } catch (ee) { }
                    }
                }
                if (this.hashira && this.hashira.active) this.hashira.update(dt, game.player, this.getActiveBoss());
            }
            draw(ctx, camera) {
                this.background.draw(ctx, camera);
                this.tiles.forEach(t => t.draw(ctx));
                this.doors.forEach(d => d.draw(ctx));
                this.healingOrbs.forEach(o => o.draw(ctx));
                if (this.hashira) this.hashira.draw(ctx);
                this.bosses.forEach(b => b.draw(ctx));
            }
            getActiveBoss() { return this.bosses.find(b => b.active && b.hp > 0); }
            reset() {
                this.bosses.forEach(b => b.reset());
                this.healingOrbs.forEach(o => o.active = true);
                if (this.hashira) this.hashira.reset();
            }
        }

        // ##################################################################
        // #                        SPRITE RENDERER                       #
        // ##################################################################
        const spriteRenderer = {
            drawTanjiro(ctx, p) {

                const anim = spriteAnimators.tanjiro;
                if (anim && anim.image) { anim.draw(ctx, 0, 0, Math.max(0.8, p.w / anim.fw), false); return; }
                const w = p.w, h = p.h;


                ctx.fillStyle = '#28282e';
                ctx.fillRect(w * 0.2, h * 0.4, w * 0.6, h * 0.6);


                const isFire = p.currentStyle === 1;
                const lightCol = isFire ? '#ff7043' : '#31645e';
                const darkCol = isFire ? '#bf360c' : '#1a1a1a';
                ctx.fillStyle = lightCol;
                ctx.fillRect(w * 0.1, h * 0.4, w * 0.8, h * 0.55);
                ctx.fillStyle = darkCol;
                for (let i = 0; i < 5; i++) {
                    for (let j = 0; j < 4; j++) {
                        if ((i + j) % 2 === 0) {
                            ctx.fillRect(w * 0.1 + i * w * 0.16, h * 0.4 + j * h * 0.14, w * 0.16, h * 0.14);
                        }
                    }
                }


                ctx.fillStyle = '#f2d3b8';
                ctx.fillRect(w * 0.2, h * 0.1, w * 0.6, h * 0.35);


                ctx.fillStyle = '#3a0e0e';
                ctx.beginPath();
                ctx.moveTo(w * 0.05, h * 0.2);
                ctx.quadraticCurveTo(w * 0.5, -h * 0.1, w * 0.95, h * 0.2);
                ctx.lineTo(w * 0.9, h * 0.3);
                ctx.lineTo(w * 0.1, h * 0.3);
                ctx.closePath();
                ctx.fill();


                ctx.fillStyle = '#a8524f';
                ctx.fillRect(w * 0.25, h * 0.15, w * 0.15, h * 0.05);


                ctx.fillStyle = '#fff';
                ctx.fillRect(w * 0.35, h * 0.25, w * 0.1, h * 0.05);
                ctx.fillRect(w * 0.55, h * 0.25, w * 0.1, h * 0.05);


                ctx.fillStyle = '#fff';
                ctx.fillRect(w * 0.15, h * 0.3, w * 0.05, h * 0.15);
                ctx.fillStyle = '#b71c1c';
                ctx.beginPath(); ctx.arc(w * 0.175, h * 0.4, w * 0.02, 0, Math.PI * 2); ctx.fill();
            },

            drawGiyu(ctx, h) {
                const anim = spriteAnimators.giyu;
                if (anim && anim.image) { anim.draw(ctx, 0, 0, Math.max(0.8, h.w / anim.fw), false); return; }
                const w = h.w, height = h.h;

                ctx.fillStyle = '#28282e'; ctx.fillRect(w * 0.2, height * 0.4, w * 0.6, height * 0.6);


                ctx.fillStyle = '#8c2727';
                ctx.fillRect(w * 0.5, height * 0.4, w * 0.45, height * 0.55);

                ctx.fillStyle = '#4caf50'; ctx.fillRect(w * 0.05, height * 0.4, w * 0.45, height * 0.55);
                ctx.fillStyle = '#ffeb3b'; ctx.fillRect(w * 0.05, height * 0.5, w * 0.45, height * 0.1);


                ctx.fillStyle = '#f2d3b8'; ctx.fillRect(w * 0.2, height * 0.1, w * 0.6, height * 0.3);
                ctx.fillStyle = '#1a1a1a'; ctx.fillRect(w * 0.1, height * 0.05, w * 0.8, height * 0.3);
            },

            drawShinobu(ctx, h) {
                const anim = spriteAnimators.shinobu;
                if (anim && anim.image) { anim.draw(ctx, 0, 0, Math.max(0.8, h.w / anim.fw), false); return; }
                const w = h.w, height = h.h;

                ctx.fillStyle = '#28282e'; ctx.fillRect(w * 0.2, height * 0.4, w * 0.6, height * 0.6);


                ctx.fillStyle = '#ffffff'; ctx.fillRect(w * 0.05, height * 0.4, w * 0.9, height * 0.55);
                ctx.fillStyle = '#ab47bc';
                ctx.beginPath(); ctx.moveTo(w * 0.05, height * 0.95); ctx.lineTo(w * 0.5, height * 0.7); ctx.lineTo(w * 0.95, height * 0.95); ctx.fill();
                ctx.fillStyle = '#4dd0e1';
                ctx.beginPath(); ctx.moveTo(w * 0.05, height * 0.85); ctx.lineTo(w * 0.5, height * 0.6); ctx.lineTo(w * 0.95, height * 0.85); ctx.fill();


                ctx.fillStyle = '#f2d3b8'; ctx.fillRect(w * 0.2, height * 0.1, w * 0.6, height * 0.3);
                ctx.fillStyle = '#1a1a1a'; ctx.fillRect(w * 0.1, height * 0.05, w * 0.8, height * 0.3);
                ctx.fillStyle = '#6a1b9a'; ctx.fillRect(w * 0.15, height * 0.25, w * 0.7, height * 0.1);
            },

            drawGyomei(ctx, h) {
                const anim = spriteAnimators.gyomei;
                if (anim && anim.image) { anim.draw(ctx, 0, 0, Math.max(0.8, h.w / anim.fw), false); return; }
                const w = h.w, height = h.h;

                ctx.fillStyle = '#28282e'; ctx.fillRect(w * 0.05, height * 0.35, w * 0.9, height * 0.65);


                ctx.fillStyle = '#4e342e'; ctx.fillRect(w * 0.05, height * 0.35, w * 0.9, height * 0.55);
                ctx.fillStyle = '#ffffff';
                ctx.font = `${height * 0.2}px serif`;
                ctx.textAlign = 'center';
                ctx.fillText('南無', w / 2, height * 0.7);


                ctx.fillStyle = '#f2d3b8'; ctx.fillRect(w * 0.1, height * 0.05, w * 0.8, height * 0.3);
                ctx.fillStyle = '#1a1a1a'; ctx.fillRect(w * 0.1, height * 0.02, w * 0.8, height * 0.2);


                ctx.fillStyle = '#b71c1c';
                for (let i = 0; i < 5; i++) {
                    ctx.beginPath(); ctx.arc(w * 0.2 + i * w * 0.15, height * 0.38, w * 0.05, 0, Math.PI * 2); ctx.fill();
                }
            },

            drawAkaza(ctx, b) {
                const anim = spriteAnimators.akaza;
                if (anim && anim.image) { anim.draw(ctx, 0, 0, Math.max(0.8, b.w / anim.fw), false); return; }
                const w = b.w, h = b.h;

                ctx.fillStyle = '#e0e0e0'; ctx.fillRect(0, h * 0.2, w, h * 0.8);

                ctx.strokeStyle = '#0077be'; ctx.lineWidth = 2;
                for (let i = 0; i < 5; i++) {
                    ctx.beginPath(); ctx.moveTo(0, h * 0.25 + i * h * 0.15); ctx.lineTo(w, h * 0.25 + i * h * 0.15); ctx.stroke();
                }

                ctx.fillStyle = '#ffffff'; ctx.fillRect(w * 0.1, h * 0.7, w * 0.8, h * 0.3);

                ctx.fillStyle = '#ff69b4'; ctx.fillRect(0, 0, w, h * 0.3);
            },

            drawDoma(ctx, b) {
                const anim = spriteAnimators.doma;
                if (anim && anim.image) { anim.draw(ctx, 0, 0, Math.max(0.8, b.w / anim.fw), false); return; }
                const w = b.w, h = b.h;

                ctx.fillStyle = '#b71c1c'; ctx.fillRect(w * 0.1, h * 0.3, w * 0.8, h * 0.7);

                ctx.fillStyle = '#f2d3b8'; ctx.fillRect(w * 0.2, h * 0.1, w * 0.6, h * 0.2);

                ctx.fillStyle = '#fffde7'; ctx.fillRect(0, 0, w, h * 0.3);

                ctx.fillStyle = '#28282e'; ctx.fillRect(w * 0.2, 0, w * 0.6, h * 0.1);
            },

            drawKokushibo(ctx, b) {
                const anim = spriteAnimators.kokushibo;
                if (anim && anim.image) { anim.draw(ctx, 0, 0, Math.max(0.8, b.w / anim.fw), false); return; }
                const w = b.w, h = b.h;

                ctx.fillStyle = '#4a148c'; ctx.fillRect(0, h * 0.35, w, h * 0.65);

                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, w, h * 0.3);
                ctx.fillRect(w * 0.8, h * 0.2, w * 0.2, h * 0.6);

                ctx.fillStyle = '#f2d3b8'; ctx.fillRect(w * 0.2, h * 0.05, w * 0.6, h * 0.3);

                ctx.fillStyle = '#ff1744';
                ctx.fillRect(w * 0.25, h * 0.15, w * 0.1, h * 0.04);
                ctx.fillRect(w * 0.45, h * 0.15, w * 0.1, h * 0.04);
                ctx.fillRect(w * 0.65, h * 0.15, w * 0.1, h * 0.04);
                ctx.fillRect(w * 0.25, h * 0.22, w * 0.1, h * 0.04);
                ctx.fillRect(w * 0.45, h * 0.22, w * 0.1, h * 0.04);
                ctx.fillRect(w * 0.65, h * 0.22, w * 0.1, h * 0.04);
            }
        };

        // ##################################################################
        // #                           ENTITIES                           #
        // ##################################################################
        class Player {
            constructor(x, y) {
                this.w = 48;
                this.h = 60;
                this.baseStats = { speed: 280, jumpForce: 700, gravity: 1800, maxHp: 100, maxFocus: 100 };
                this.reset(x, y);
            }
            reset(x, y) {
                this.endAttack();
                Object.assign(this, this.baseStats, {
                    x, y, vx: 0, vy: 0, facing: 1, onGround: false, onWall: false, wallSlideSpeed: 150, jumpCount: 0,
                    isDashing: false, dashTimer: 0, dashCooldown: 0, isParrying: false, parryTimer: 0, parryCooldown: 0,
                    invulnerableTimer: 0, hp: this.baseStats.maxHp, focus: this.baseStats.maxFocus, currentStyle: 0,
                    skills: [
                        {
                            'F': { cooldown: 0, maxCooldown: 1.0, cost: 0 }, 'X': { cooldown: 0, maxCooldown: 0.3, cost: 0 },
                            '1': { cooldown: 0, maxCooldown: 2, cost: 20 }, '2': { cooldown: 0, maxCooldown: 4, cost: 35 },
                            '3': { cooldown: 0, maxCooldown: 8, cost: 50 },
                        },
                        {
                            'F': { cooldown: 0, maxCooldown: 1.0, cost: 0 }, 'X': { cooldown: 0, maxCooldown: 0.4, cost: 5 },
                            '1': { cooldown: 0, maxCooldown: 3, cost: 30 }, '2': { cooldown: 0, maxCooldown: 6, cost: 45 },
                            '3': { cooldown: 0, maxCooldown: 10, cost: 70 },
                        }
                        ,
                        {
                            'F': { cooldown: 0, maxCooldown: 0.9, cost: 0 }, 'X': { cooldown: 0, maxCooldown: 0.35, cost: 0 },
                            '1': { cooldown: 0, maxCooldown: 2.5, cost: 25 }, '2': { cooldown: 0, maxCooldown: 5, cost: 40 },
                            '3': { cooldown: 0, maxCooldown: 9, cost: 65 },
                        },
                        {
                            'F': { cooldown: 0, maxCooldown: 1.2, cost: 0 }, 'X': { cooldown: 0, maxCooldown: 0.5, cost: 0 },
                            '1': { cooldown: 0, maxCooldown: 3.5, cost: 30 }, '2': { cooldown: 0, maxCooldown: 6, cost: 45 },
                            '3': { cooldown: 0, maxCooldown: 12, cost: 80 },
                        }
                    ],
                    activeAttack: null,

                    breathing: { style: 'Water', timer: 0, period: 1000, strength: 1 }
                });
            }
            update(dt, level) {

                if (!this.breathing) this.breathing = { style: 'Water', timer: 0, period: 1000, strength: 1 };
                this.breathing.timer += dt * 1000;
                if (this.breathing.timer > this.breathing.period) this.breathing.timer -= this.breathing.period;

                ['dashCooldown', 'invulnerableTimer', 'parryCooldown'].forEach(t => { if (this[t] > 0) this[t] -= dt; });
                this.skills.forEach(style => Object.values(style).forEach(s => { if (s.cooldown > 0) s.cooldown -= dt; }));
                this.focus = Math.min(this.maxFocus, this.focus + 15 * dt);
                if (this.isParrying) { this.parryTimer -= dt; if (this.parryTimer <= 0) this.isParrying = false; }
                if (this.activeAttack) { this.activeAttack.timer -= dt; if (this.activeAttack.timer <= 0) this.endAttack(); }
                if (!this.isDashing && !this.activeAttack) { this.vx = 0; if (input.left) { this.vx = -this.speed; this.facing = -1; } if (input.right) { this.vx = this.speed; this.facing = 1; } }
                if (input.dashPressed && this.dashCooldown <= 0 && !this.activeAttack) {
                    this.isDashing = true; this.dashTimer = 0.15; this.vx = this.facing * 700; this.vy = 0; this.dashCooldown = 0.6; audio.playSound('dash');
                    particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h / 2, count: 20, color: '#a7d8f5', speed: 150, size: 4, lifetime: 0.4, glow: true });
                }
                if (this.isDashing) { this.dashTimer -= dt; if (this.dashTimer <= 0) this.isDashing = false; }
                if (!this.activeAttack) {
                    if (input.switchStylePressed) {
                        this.currentStyle = (this.currentStyle + 1) % 2; audio.playSound('switch_style');
                        particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h / 2, count: 25, color: this.currentStyle === 0 ? '#42a5f5' : '#ff7043', speed: 100, size: 4, lifetime: 0.5, glow: true });
                    }
                    const style = this.skills[this.currentStyle];
                    if (input.parryPressed && style['F'].cooldown <= 0) this.useSkill('F');
                    else if (input.attackPressed && style['X'].cooldown <= 0 && this.focus >= style['X'].cost) this.useSkill('X');
                    else if (input.skill1Pressed && style['1'].cooldown <= 0 && this.focus >= style['1'].cost) this.useSkill('1');
                    else if (input.skill2Pressed && style['2'].cooldown <= 0 && this.focus >= style['2'].cost) this.useSkill('2');
                    else if (input.skill3Pressed && style['3'].cooldown <= 0 && this.focus >= style['3'].cost) this.useSkill('3');
                }
                if (!this.isDashing) { this.vy += this.gravity * dt; }
                if (input.jumpPressed && !this.activeAttack) {
                    if (this.onGround) { this.vy = -this.jumpForce; this.jumpCount = 1; audio.playSound('jump'); particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h, count: 5, color: '#ccc', speed: 100, size: 3, lifetime: 0.3, angle: -Math.PI / 2, spread: Math.PI / 2 }); }
                    else if (this.jumpCount < 2 && !this.onWall) { this.vy = -this.jumpForce * 0.9; this.jumpCount = 2; audio.playSound('jump', 0.8); }
                    else if (this.onWall) { this.vy = -this.jumpForce; this.vx = -this.facing * this.speed * 1.2; this.onWall = false; audio.playSound('jump'); }
                }
                if (this.onWall && !this.onGround && this.vy > 0) { this.vy = Math.min(this.vy, this.wallSlideSpeed); if (Math.random() < 0.2) particleManager.spawn({ x: this.facing > 0 ? this.x + this.w : this.x, y: this.y + Math.random() * this.h, count: 1, color: '#ccc', speed: 20, size: 2, lifetime: 0.2 }); }
                this.x += this.vx * dt; this.handleCollisions(level.tiles, 'x');
                this.y += this.vy * dt; this.handleCollisions(level.tiles, 'y');
                if (this.hp <= 0) game.setState('gameOver');
            }
            endAttack() {
                if (!this.activeAttack) return;
                if (this.activeAttack.intervalId) clearInterval(this.activeAttack.intervalId);
                if (this.activeAttack.isForcedDash) this.isDashing = false;
                this.activeAttack = null;
            }
            useSkill(key) {
                const style = this.skills[this.currentStyle];
                const skill = style[key];
                if (this.focus < skill.cost) return;
                this.focus -= skill.cost;
                skill.cooldown = skill.maxCooldown;
                if (key === 'F') {
                    this.isParrying = true; this.parryTimer = 0.15; audio.playSound('parry_fail', 0.3);
                    particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h / 2, count: 1, color: '#FFFFFF', speed: 0, size: this.w, lifetime: 0.15, shrink: 0.8, glow: true });
                    return;
                }
                this.activeAttack = { key, timer: 0, intervalId: null, isForcedDash: false };
                if (this.currentStyle === 0) {
                    audio.playSound('skill_water');
                    if (key === 'X') {
                        this.activeAttack.timer = 0.25;
                        const hX = this.x + (this.facing > 0 ? this.w : -48);
                        game.checkPlayerAttack(hX, this.y, 48, this.h, 5);

                        for (let i = 0; i < 2; i++) {
                            const offset = (i === 0) ? 12 : 28;
                            const proj = projectilePool.get();
                            if (proj) proj.activate(hX + (this.facing > 0 ? offset : -offset), this.y + this.h / 2, this.facing > 0 ? -0.2 + i * 0.15 : Math.PI + 0.2 - i * 0.15, 420, 6, '#58b1e0', 0.9, true);
                        }
                        for (let i = 0; i < 3; i++) setTimeout(() => particleManager.spawn({ x: hX + (this.facing * i * 15), y: this.y + this.h / 2, count: 3, color: '#58b1e0', speed: 50, size: 3, lifetime: 0.3, angle: this.facing > 0 ? 0 : Math.PI, spread: 0.5, glow: true }), i * 50);
                    } else if (key === '1') {
                        this.activeAttack.timer = 0.6;
                        const hX = this.x + (this.facing > 0 ? this.w : -120);
                        game.checkPlayerAttack(hX, this.y - 10, 120, this.h + 20, 18);
                        particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h / 2, count: 30, color: '#42a5f5', speed: [100, 200], size: [2, 5], lifetime: 0.6, angle: this.facing > 0 ? 0 : Math.PI, spread: Math.PI / 4, glow: true });

                        for (let i = -2; i <= 2; i++) {
                            const proj = projectilePool.get();
                            if (proj) proj.activate(this.x + this.w / 2, this.y + this.h / 2, (this.facing > 0 ? 0 : Math.PI) + i * 0.15, 500, 10, '#4fc3f7', 1.2, true);
                        }
                    } else if (key === '2') {
                        this.activeAttack.timer = 0.5; this.vy = -200; this.vx = this.facing * 150;

                        this.activeAttack.intervalId = setInterval(() => {
                            if (!this.activeAttack) return;
                            game.checkPlayerAttack(this.x - 30, this.y - 30, this.w + 60, this.h + 60, 8);
                            particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h / 2, count: 8, color: '#42a5f5', speed: 150, size: 4, lifetime: 0.4, glow: true });

                            const proj = projectilePool.get();
                            if (proj) proj.activate(this.x + this.w / 2, this.y + this.h / 2, Math.PI / 2 + (this.facing > 0 ? -0.3 : 0.3), 360, 9, '#42a5f5', 1.0, false);
                        }, 60);
                    } else if (key === '3') {
                        this.activeAttack.timer = 0.6; this.activeAttack.isForcedDash = true; this.isDashing = true; this.vx = this.facing * 420;
                        this.activeAttack.intervalId = setInterval(() => {
                            if (!this.activeAttack) return; game.checkPlayerAttack(this.x, this.y, this.w, this.h, 12);
                            particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h / 2, count: 15, color: '#1e88e5', speed: 220, size: 5, lifetime: 0.5, angle: this.facing > 0 ? Math.PI : 0, spread: Math.PI / 2, glow: true });

                            const proj = projectilePool.get(); if (proj) proj.activate(this.x + (this.facing > 0 ? this.w : -20), this.y + this.h / 2, this.facing > 0 ? 0 : Math.PI, 480, 14, '#1e88e5', 1.1, true);
                        }, 40);
                    }
                }
                else if (this.currentStyle === 1) {
                    audio.playSound('skill_fire');
                    if (key === 'X') {
                        this.activeAttack.timer = 0.3;
                        const hX = this.x + (this.facing > 0 ? this.w : -56);
                        game.checkPlayerAttack(hX, this.y, 56, this.h, 8);
                        particleManager.spawn({ x: hX + (this.facing * 28), y: this.y + this.h / 2, count: 12, color: '#ff7043', speed: 100, size: 6, lifetime: 0.45, angle: this.facing > 0 ? 0 : Math.PI, spread: 0.6, glow: true });

                        const proj = projectilePool.get(); if (proj) proj.activate(hX + (this.facing > 0 ? 16 : -16), this.y + this.h / 2, this.facing > 0 ? 0 : Math.PI, 520, 12, '#ff8a50', 1.0, true);
                    } else if (key === '1') {
                        this.activeAttack.timer = 0.25;
                        game.checkPlayerAttack(this.x - 80, this.y - 80, this.w + 160, this.h + 160, 22); screenEffects.shake(0.25, 10);
                        particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h / 2, count: 80, color: '#ff5722', speed: 340, size: 8, lifetime: 1.1, glow: true });

                        for (let i = 0; i < 10; i++) {
                            const a = (i / 10) * Math.PI * 2;
                            const p = projectilePool.get(); if (p) p.activate(this.x + this.w / 2, this.y + this.h / 2, a, 420, 14, '#ff7043', 1.4, true);
                        }
                    } else if (key === '2') {
                        this.activeAttack.timer = 1.0; this.vy = -this.jumpForce; this.jumpCount = 1; setTimeout(() => { this.vy = 1200; }, 150);
                        this.activeAttack.intervalId = setInterval(() => {
                            if (!this.activeAttack || this.onGround) { this.endAttack(); return; }
                            game.checkPlayerAttack(this.x - 20, this.y, this.w + 40, this.h + 20, 15);
                            particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h, count: 8, color: '#f4511e', speed: 100, size: 6, lifetime: 0.5, angle: Math.PI / 2, spread: Math.PI / 3, glow: true });

                            const fp = projectilePool.get(); if (fp) fp.activate(this.x + this.w / 2, this.y + this.h / 2, this.facing > 0 ? 0 : Math.PI, 480, 16, '#ff6e40', 1.0, false);
                        }, 35);
                    } else if (key === '3') {
                        this.activeAttack.timer = 1.0; this.invulnerableTimer = 1.0;
                        particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h / 2, count: 120, color: '#bf360c', speed: 420, size: [4, 12], lifetime: 1.2, gravity: 200, glow: true });
                        setTimeout(() => {
                            if (!this.activeAttack) return; game.checkPlayerAttack(this.x - 200, this.y - 200, this.w + 400, this.h + 400, 50); screenEffects.shake(0.6, 22);

                            for (let i = 0; i < 12; i++) {
                                const a = (i / 12) * Math.PI * 2;
                                const bp = projectilePool.get(); if (bp) bp.activate(this.x + this.w / 2, this.y + this.h / 2, a, 520, 18, '#ff7043', 1.4, true);
                            }
                        }, 500);
                    }
                }
                else if (this.currentStyle === 2) {
                    audio.playSound('skill_wind');
                    if (key === 'X') {
                        this.activeAttack.timer = 0.25; const hX = this.x + (this.facing > 0 ? this.w : -64); game.checkPlayerAttack(hX, this.y, 64, this.h, 7);
                        particleManager.spawn({ x: hX, y: this.y + this.h / 2, count: 15, color: '#c8fdff', speed: 260, size: 4, lifetime: 0.45, angle: this.facing > 0 ? 0 : Math.PI, spread: 0.4, glow: true });
                    } else if (key === '1') {
                        this.activeAttack.timer = 0.6; const hX = this.x + (this.facing > 0 ? this.w : -200); game.checkPlayerAttack(hX, this.y - 20, 200, this.h + 40, 18);

                        for (let i = 0; i < 30; i++) setTimeout(() => particleManager.spawn({ x: this.x + this.w / 2 + (Math.random() - 0.5) * 30, y: this.y + this.h / 2 + (Math.random() - 0.5) * 30, count: 1, color: '#c8fdff', speed: 200, size: 4, lifetime: 0.6, glow: true }), i * 12);
                    } else if (key === '2') {
                        this.activeAttack.timer = 0.8; this.vy = -250; this.vx = this.facing * 180;
                        this.activeAttack.intervalId = setInterval(() => { if (!this.activeAttack) return; game.checkPlayerAttack(this.x - 20, this.y - 20, this.w + 40, this.h + 20, 10); particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h / 2, count: 6, color: '#c8fdff', speed: 120, size: 4, lifetime: 0.35, glow: true }); }, 60);
                    } else if (key === '3') {
                        this.activeAttack.timer = 0.9; this.invulnerableTimer = 0.8; particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h / 2, count: 80, color: '#bfefff', speed: 300, size: [3, 7], lifetime: 0.8, glow: true });
                        setTimeout(() => { if (!this.activeAttack) return; game.checkPlayerAttack(this.x - 220, this.y - 220, this.w + 440, this.h + 440, 40); screenEffects.shake(0.4, 10); }, 400);
                    }
                }
                else if (this.currentStyle === 3) {
                    audio.playSound('skill_stone');
                    if (key === 'X') {
                        this.activeAttack.timer = 0.35; const hX = this.x + (this.facing > 0 ? this.w : -64); game.checkPlayerAttack(hX, this.y, 64, this.h, 10);
                        particleManager.spawn({ x: hX, y: this.y + this.h / 2, count: 12, color: '#c6b89f', speed: 120, size: 6, lifetime: 0.6, gravity: 200, glow: false });
                    } else if (key === '1') {
                        this.activeAttack.timer = 0.5;
                        const slamX = this.x + (this.facing > 0 ? this.w / 2 : -this.w / 2);
                        particleManager.spawn({ x: slamX, y: this.y + this.h, count: 60, color: '#a1887f', speed: 320, size: 8, lifetime: 1.2, glow: false });
                        setTimeout(() => { game.checkPlayerAttack(slamX - 180, this.y - 40, 360, this.h + 80, 30); screenEffects.shake(0.5, 14); }, 120);
                    } else if (key === '2') {
                        this.activeAttack.timer = 0.8; this.vy = -200; this.vx = this.facing * 120; this.activeAttack.intervalId = setInterval(() => { if (!this.activeAttack) return; particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h, count: 6, color: '#bdb2a7', speed: 80, size: 6, lifetime: 0.5, gravity: 300 }); game.checkPlayerAttack(this.x - 10, this.y, this.w + 20, this.h + 10, 12); }, 80);
                    } else if (key === '3') {
                        this.activeAttack.timer = 1.0; this.invulnerableTimer = 0.6; particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h / 2, count: 120, color: '#8d6e63', speed: 500, size: [6, 12], lifetime: 1.6, gravity: 400 });
                        setTimeout(() => { game.checkPlayerAttack(this.x - 260, this.y - 260, this.w + 520, this.h + 520, 60); screenEffects.shake(0.8, 22); }, 600);
                    }
                }
            }
            handleCollisions(tiles, axis) {
                this.onGround = false; this.onWall = false;
                tiles.forEach(tile => {
                    if (this.x < tile.x + tile.w && this.x + this.w > tile.x && this.y < tile.y + tile.h && this.y + this.h > tile.y) {
                        if (tile.type === 'spike' && this.invulnerableTimer <= 0) { this.takeDamage(10); }
                        else if (tile.type !== 'spike') {
                            if (axis === 'y') {
                                if (this.vy > 0) { this.y = tile.y - this.h; this.vy = 0; this.onGround = true; this.jumpCount = 0; this.dashCooldown = Math.min(this.dashCooldown, 0.1); }
                                else if (this.vy < 0) { this.y = tile.y + tile.h; this.vy = 0; }
                            }
                            if (axis === 'x') {
                                if (this.vx > 0) { this.x = tile.x - this.w; this.onWall = true; }
                                else if (this.vx < 0) { this.x = tile.x + tile.w; this.onWall = true; }
                            }
                        }
                    }
                });
            }
            heal(amount) {
                this.hp = Math.min(this.maxHp, this.hp + amount); audio.playSound('heal');
                particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h / 2, count: 20, color: '#4caf50', speed: 100, size: 4, lifetime: 0.6, gravity: -100, glow: true });
            }
            takeDamage(amount) {
                if (this.invulnerableTimer > 0) return;
                if (this.isParrying) {
                    this.isParrying = false; this.invulnerableTimer = 0.5; audio.playSound('parry_success'); screenEffects.shake(0.1, 10);
                    particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h / 2, count: 50, color: '#FFFF00', speed: 300, size: 5, lifetime: 0.5, glow: true });
                    const hX = this.x + (this.facing > 0 ? this.w : -200); game.checkPlayerAttack(hX, this.y - 20, 200, this.h + 40, 25);
                    return;
                }
                this.hp -= amount; this.invulnerableTimer = 1.0; this.endAttack(); audio.playSound('hit_player'); screenEffects.shake(0.2, 8);
                particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h / 2, count: 15, color: '#ff4d4d', speed: 200, size: 3, lifetime: 0.5 });
            }
            draw(ctx) {
                if (this.invulnerableTimer > 0 && Math.floor(this.invulnerableTimer * 10) % 2 === 0) return;


                const cx = this.x + this.w / 2;
                const cy = this.y + this.h / 2;
                const t = (this.breathing && this.breathing.period) ? (this.breathing.timer / this.breathing.period) : 0;
                const pulse = 0.6 + 0.4 * Math.sin(t * Math.PI * 2);
                const styleIdx = this.currentStyle || 0;
                if (styleIdx === 0) {

                    const grd = ctx.createRadialGradient(cx, cy, 4, cx, cy, 100 * pulse);
                    grd.addColorStop(0, `rgba(66,165,245,${0.25 * pulse})`);
                    grd.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.save(); ctx.fillStyle = grd; ctx.beginPath(); ctx.arc(cx, cy, 80 * pulse, 0, Math.PI * 2); ctx.fill(); ctx.restore();
                } else {

                    ctx.save(); ctx.fillStyle = `rgba(255,112,67,${0.18 * pulse})`; ctx.beginPath(); ctx.ellipse(cx, cy, 70 * pulse, 36 * pulse, 0, 0, Math.PI * 2); ctx.fill(); ctx.restore();
                }


                ctx.save();
                if (this.facing < 0) {
                    ctx.scale(-1, 1);
                    ctx.translate(-this.x - this.w, this.y);
                } else {
                    ctx.translate(this.x, this.y);
                }
                spriteRenderer.drawTanjiro(ctx, this);
                ctx.restore();
            }
        }

        // ##################################################################
        // #                           HASHIRA                            #
        // ##################################################################
        class Hashira {
            constructor(config) {
                Object.assign(this, { w: 48, h: 64, vx: 0, vy: 0, x: 0, y: 0, active: false, state: 'idle', stateTimer: 2, facing: 1, ...config });
            }
            activate() { this.active = true; this.state = 'idle'; this.stateTimer = 1; }
            reset() { this.active = false; this.x = this.startX; this.y = this.startY; }
            update(dt, player, boss) {
                if (!this.active || !boss) { this.state = 'idle'; return; }
                this.stateTimer -= dt;

                if (boss.x > this.x) this.facing = 1;
                else this.facing = -1;

                if (this.stateTimer <= 0) { this.chooseAction(player, boss); }
                this.x += this.vx * dt; this.y += this.vy * dt;
            }
            chooseAction(player, boss) { this.state = 'idle'; }
            draw(ctx) {
                if (!this.active) return;
                ctx.save();
                if (this.facing < 0) {
                    ctx.scale(-1, 1);
                    ctx.translate(-this.x - this.w, this.y);
                } else {
                    ctx.translate(this.x, this.y);
                }


                ctx.save();
                if (this.spriteKey === 'giyu') { ctx.fillStyle = 'rgba(79,193,247,0.12)'; ctx.beginPath(); ctx.ellipse(this.w / 2, this.h / 2, this.w * 1.4, this.h * 0.9, 0, 0, Math.PI * 2); ctx.fill(); }
                if (this.spriteKey === 'shinobu') { ctx.fillStyle = 'rgba(171,71,188,0.12)'; ctx.beginPath(); ctx.ellipse(this.w / 2, this.h / 2, this.w * 1.4, this.h * 0.9, 0, 0, Math.PI * 2); ctx.fill(); }
                if (this.spriteKey === 'gyomei') { ctx.fillStyle = 'rgba(161,136,127,0.12)'; ctx.beginPath(); ctx.ellipse(this.w / 2, this.h / 2, this.w * 1.6, this.h * 1.0, 0, 0, Math.PI * 2); ctx.fill(); }
                ctx.restore();

                switch (this.spriteKey) {
                    case 'giyu': spriteRenderer.drawGiyu(ctx, this); break;
                    case 'shinobu': spriteRenderer.drawShinobu(ctx, this); break;
                    case 'gyomei': spriteRenderer.drawGyomei(ctx, this); break;
                }
                ctx.restore();
            }
        }
        class Giyu extends Hashira {
            constructor(x, y) { super({ name: "Giyu Tomioka", startX: x, startY: y, color: '#0d47a1', spriteKey: 'giyu' }); }
            chooseAction(player, boss) {
                const distance = Math.hypot(this.x - boss.x, this.y - boss.y); const action = Math.random();
                if (action < 0.6 && distance > 100) {
                    this.state = 'moving'; this.stateTimer = 1.5; const angle = Math.atan2(boss.y - this.y, boss.x - this.x);
                    this.vx = Math.cos(angle) * 200;
                } else if (action < 0.85) {
                    this.state = 'attacking'; this.stateTimer = 0.8; this.vx = (boss.x > this.x ? 1 : -1) * 400;
                    setTimeout(() => {
                        if (!this.active) return; game.checkHashiraAttack(this.x, this.y - 10, this.w, this.h + 20, 10, '#4fc3f7');
                        this.vx = 0;
                    }, 300);
                } else {
                    this.state = 'defending'; this.stateTimer = 2.0; this.vx = 0;
                }
            }
        }
        class Shinobu extends Hashira {
            constructor(x, y) { super({ name: "Shinobu Kocho", startX: x, startY: y, color: '#6a1b9a', spriteKey: 'shinobu' }); }
            chooseAction(player, boss) {
                const action = Math.random();
                if (action < 0.7) {
                    this.state = 'attacking'; this.stateTimer = 1.2;
                    const targetX = boss.x + (Math.random() - 0.5) * 100; const targetY = boss.y - 50;
                    const angle = Math.atan2(targetY - this.y, targetX - this.x);
                    this.vx = Math.cos(angle) * 800; this.vy = Math.sin(angle) * 800;
                    setTimeout(() => {
                        if (!this.active || !boss) return; this.vx = 0; this.vy = 0;
                        game.checkHashiraAttack(boss.x, boss.y, boss.w, boss.h, 5, '#ab47bc'); boss.applyPoison(5, 4);
                    }, 200);
                } else {
                    this.state = 'repositioning'; this.stateTimer = 1.0; const targetX = player.x + (player.facing * -100);
                    const angle = Math.atan2(player.y - this.y, targetX - this.x);
                    this.vx = Math.cos(angle) * 300; this.vy = Math.sin(angle) * 300;
                }
            }
        }
        class Gyomei extends Hashira {
            constructor(x, y) { super({ name: "Gyomei Himejima", startX: x, startY: y, w: 56, h: 72, color: '#4e342e', spriteKey: 'gyomei' }); }
            chooseAction(player, boss) {
                const action = Math.random();
                if (action < 0.6) {
                    this.state = 'attacking'; this.stateTimer = 2.5; this.vx = 0;
                    particleManager.spawn({ x: this.x + this.w / 2, y: this.y, count: 20, color: '#757575', speed: 100, angle: -Math.PI / 2, spread: Math.PI / 2, lifetime: 1.0 });
                    setTimeout(() => {
                        if (!this.active) return;
                        game.checkHashiraAttack(this.x - 100, this.y - 50, this.w + 200, this.h + 50, 20, '#a1887f');
                        screenEffects.shake(0.2, 10);
                    }, 1000);
                } else {
                    this.state = 'moving'; this.stateTimer = 2.0;
                    const angle = Math.atan2(boss.y - this.y, boss.x - this.x);
                    this.vx = Math.cos(angle) * 100;
                }
            }
        }

        // --- HashiraManager (registers assist behavior and visuals)
        const HashiraManager = {
            registry: {},
            register(key, cfg) { this.registry[key] = cfg; },
            assist(key) { const cfg = this.registry[key]; if (cfg && cfg.assist) cfg.assist(); }
        };

        // --- Cutscene manager (simple scripted scenes)
        const CutsceneManager = {
            active: false, queue: [], start(seq) { this.queue = seq; this.active = true; this.index = 0; this.next(); },
            next() { if (this.index >= this.queue.length) { this.active = false; return; } const s = this.queue[this.index++]; dialogueManager.start([{ speaker: s.speaker, text: s.text }]); }
        };

        // ##################################################################
        // #                            BOSSES                            #
        // ##################################################################
        class Boss {
            constructor(config) { Object.assign(this, { w: 64, h: 80, facing: 1, invulnerableTimer: 0, poisonTimer: 0, poisonDps: 0, ...config }); }
            activate() { this.active = true; this.state = 'idle'; this.timer = 2; }

            update(dt, player) {
                if (!this.active || this.hp <= 0) return;
                if (this.invulnerableTimer > 0) this.invulnerableTimer -= dt;
                if (this.poisonTimer > 0) { this.poisonTimer -= dt; this.hp -= this.poisonDps * dt; }

                if (player.x + player.w / 2 > this.x + this.w / 2) { this.facing = 1; } else { this.facing = -1; }

                this.updatePhases(); this.timer -= dt;
                if (this.state === 'transition' && this.timer <= 0) this.state = 'idle';
                if (this.state !== 'transition' && this.timer <= 0) this.chooseAction(player);
                this.executeAction(dt, player);
            }
            updatePhases() { }
            chooseAction(player) { }
            executeAction(dt, player) { }
            takeDamage(amount) {
                if (this.invulnerableTimer > 0 || !this.active || this.state === 'transition') return;
                this.hp -= amount; this.invulnerableTimer = 0.1; game.hitStop = 0.05; audio.playSound('hit_enemy');
                particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h / 2, count: 10, color: '#ffffff', speed: 150, size: 3, lifetime: 0.4 });
                if (this.hp <= 0) this.die();
            }
            applyPoison(duration, dps) { this.poisonTimer = Math.max(this.poisonTimer, duration); this.poisonDps = dps; }
            collidesWith(e) { return this.x < e.x + e.w && this.x + this.w > e.x && this.y < e.y + e.h && this.y + this.h > e.y; }
            die() {
                this.active = false; game.bossDefeated();
                particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h / 2, count: 150, color: this.particleColor, speed: 500, size: 6, lifetime: 2.0, glow: true });
                screenEffects.shake(1.0, 25);
            }
            reset() { this.hp = this.maxHp; this.phase = 1; this.state = 'idle'; this.active = false; this.x = this.startX; this.y = this.startY; this.poisonTimer = 0; }
            draw(ctx) {
                if (!this.active) return;
                if (this.invulnerableTimer > 0 && Math.floor(this.invulnerableTimer * 20) % 2 === 0) return;
                ctx.save();

                if (this.state === 'telegraph') {
                    const progress = Math.min(1, Math.max(0, 1 - (this.timer / 2)));
                    drawTelegraphRing(ctx, this.x + this.w / 2, this.y + this.h / 2, Math.max(this.w, this.h) * 1.4, this.particleColor || '#fff', progress);
                    ctx.globalAlpha = 0.5 + Math.sin(performance.now() / 100) * 0.5;
                }
                if (this.poisonTimer > 0) { ctx.filter = 'sepia(100%) hue-rotate(240deg) saturate(3)'; }

                ctx.save();
                if (this.facing < 0) {
                    ctx.scale(-1, 1);
                    ctx.translate(-this.x - this.w, this.y);
                } else {
                    ctx.translate(this.x, this.y);
                }

                switch (this.spriteKey) {
                    case 'akaza': spriteRenderer.drawAkaza(ctx, this); break;
                    case 'doma': spriteRenderer.drawDoma(ctx, this); break;
                    case 'kokushibo': spriteRenderer.drawKokushibo(ctx, this); break;
                }
                ctx.restore();

                ctx.restore();
            }
        }
        class Akaza extends Boss {
            constructor(x, y) { super({ name: "Akaza, Upper Moon 3", spriteKey: 'akaza', maxHp: 150, startX: x, startY: y, w: 64, h: 80, color: '#d43d81', p2Color: '#f55f9f', p3Color: '#ff8ac7', particleColor: '#ff69b4' }); }
            updatePhases() {
                if (this.hp < this.maxHp * 0.66 && this.phase === 1) { this.phase = 2; this.state = 'transition'; this.timer = 1.5; screenEffects.shake(0.5, 15); }
                else if (this.hp < this.maxHp * 0.33 && this.phase === 2) { this.phase = 3; this.state = 'transition'; this.timer = 1.5; screenEffects.shake(0.8, 20); }
            }
            chooseAction(p) {
                let a = Math.random();
                if (this.phase === 1) { if (a < 0.8) this.telegraphDash(p, 400); else this.idle(1.5); }
                else if (this.phase === 2) { if (a < 0.6) this.telegraphDash(p, 600); else if (a < 0.9) this.telegraphJump(p); else this.idle(1.0); }
                else if (this.phase === 3) { if (a < 0.4) this.telegraphDash(p, 800); else if (a < 0.7) this.telegraphJump(p); else this.shockwave(); }
            }
            executeAction(dt, player) { if (this.state === 'dash') { this.x += this.vx * dt; this.y += this.vy * dt; if (this.collidesWith(player)) player.takeDamage(15); } }
            idle(d) { this.state = 'idle'; this.timer = d; }
            telegraphDash(p, s) { this.state = 'telegraph'; this.timer = 0.6; const dx = p.x - this.x, dy = p.y - this.y, mag = Math.hypot(dx, dy) || 1; this.vx = (dx / mag) * s; this.vy = (dy / mag) * s; setTimeout(() => { if (this.hp > 0 && this.active) { this.state = 'dash'; this.timer = 0.5; } }, 600); }
            telegraphJump(p) { this.state = 'telegraph'; this.timer = 0.8; this.targetX = p.x; setTimeout(() => { if (this.hp > 0 && this.active) { this.state = 'airborne'; this.x = this.targetX; this.y = p.y - 100; this.timer = 0.5; setTimeout(() => { if (this.hp > 0 && this.active) this.state = 'idle'; }, 500); } }, 800); }
            shockwave() { this.state = 'telegraph'; this.timer = 1.0; setTimeout(() => { if (this.hp > 0 && this.active) { this.state = 'idle'; this.timer = 2.0; particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h, count: 50, color: '#ff69b4', speed: 400, size: 5, lifetime: 1.0, glow: true }); screenEffects.shake(0.3, 10); if (game.player.onGround && game.currentRoom === this.room) game.player.takeDamage(20); } }, 1000); }
        }
        class Doma extends Boss {
            constructor(x, y) { super({ name: "Doma, Upper Moon 2", spriteKey: 'doma', maxHp: 200, startX: x, startY: y, w: 70, h: 85, color: '#a0d2eb', p2Color: '#4d80e4', p3Color: '#82eefd', particleColor: '#a0d2eb' }); }
            updatePhases() { if (this.hp < this.maxHp * 0.5 && this.phase === 1) { this.phase = 2; this.state = 'transition'; this.timer = 2; screenEffects.shake(0.6, 15); } }
            chooseAction(p) {
                let a = Math.random();
                if (this.phase === 1) { if (a < 0.5) this.iceShards(p); else if (a < 0.9) this.teleport(p); else this.iceClone(); }
                else { if (a < 0.4) this.iceShards(p, 10); else if (a < 0.7) this.teleport(p); else this.freezingCloud(); }
            }
            teleport(p) { this.state = 'telegraph'; this.timer = 0.5; particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h / 2, count: 30, color: '#a0d2eb', speed: 200, size: 5, lifetime: 0.5, glow: true }); setTimeout(() => { if (this.hp > 0 && this.active) { this.x = p.x + (Math.random() > 0.5 ? -200 : 200); this.y = p.y - 50; this.state = 'idle'; this.timer = 1.0; particleManager.spawn({ x: this.x + this.w / 2, y: this.y + this.h / 2, count: 30, color: '#a0d2eb', speed: 200, size: 5, lifetime: 0.5, glow: true }); } }, 500); }
            iceShards(p, count = 5) { this.state = 'telegraph'; this.timer = 1.2; audio.playSound('skill_ice'); setTimeout(() => { if (this.hp > 0 && this.active) { this.state = 'idle'; this.timer = 1.5; for (let i = 0; i < count; i++) { setTimeout(() => { if (!this.active) return; const proj = projectilePool.get(); if (proj) proj.activate(this.x + this.w / 2, this.y + this.h / 2, Math.atan2(game.player.y - this.y, game.player.x - this.x), 400, 10, '#fff', 2.0); }, i * 100); } } }, 1200); }
            iceClone() { this.state = 'telegraph'; this.timer = 0.8; setTimeout(() => { if (this.hp > 0 && this.active) { this.state = 'idle'; this.timer = 2.0; const proj = projectilePool.get(); if (proj) proj.activate(this.x - 100, this.y, 0, 0, 15, '#a0d2eb', 3.0, false, true); } }, 800); }
            freezingCloud() { this.state = 'telegraph'; this.timer = 1.5; setTimeout(() => { if (this.hp > 0 && this.active) { this.state = 'idle'; this.timer = 3.0; screenEffects.shake(0.4, 10); particleManager.spawn({ x: GAME_WIDTH / 2, y: 600, count: 200, color: '#e0f7fa', speed: 50, size: 8, lifetime: 3, angle: -Math.PI / 2, spread: Math.PI / 4, gravity: -100, glow: true }); const attackInterval = setInterval(() => { if (!this.active || game.player.hp <= 0) { clearInterval(attackInterval); return; } if (game.player.onGround && game.currentRoom === this.room) game.player.takeDamage(5); }, 200); setTimeout(() => clearInterval(attackInterval), 3000); } }, 1500); }
        }

        class Kokushibo extends Boss {
            constructor(x, y) {
                super({
                    name: "Kokushibo, Upper Moon 1",
                    spriteKey: 'kokushibo',
                    maxHp: 250,
                    startX: x,
                    startY: y,
                    w: 60,
                    h: 90,
                    color: '#4a148c',
                    p2Color: '#7b1fa2',
                    p3Color: '#9c27b0',
                    particleColor: '#ce93d8'
                });
                this.attackLock = false;
                this.lastAttackTime = 0;
            }

            updatePhases() {
                if (this.hp < this.maxHp * 0.7 && this.phase === 1) {
                    this.phase = 2;
                    this.state = 'transition';
                    this.timer = 1.5;
                    screenEffects.shake(0.7, 18);
                }
                else if (this.hp < this.maxHp * 0.4 && this.phase === 2) {
                    this.phase = 3;
                    this.state = 'transition';
                    this.timer = 1.5;
                    screenEffects.shake(1.0, 22);
                }
            }

            chooseAction(player) {

                if (this.attackLock) return;


                const currentTime = performance.now();
                if (currentTime - this.lastAttackTime < 1000) return;

                let a = Math.random();
                if (this.phase === 1) {
                    if (a < 0.7) this.moonSlash();
                    else this.teleport();
                }
                else if (this.phase === 2) {
                    if (a < 0.5) this.moonSlash(3);
                    else if (a < 0.8) this.multiSlash();
                    else this.teleport();
                }
                else {
                    if (a < 0.4) this.multiSlash();
                    else if (a < 0.8) this.moonVortex();
                    else this.teleport();
                }
            }


            safeExecuteAttack(attackFunction, duration) {
                if (this.attackLock || !this.active || this.hp <= 0) return;

                this.attackLock = true;
                this.lastAttackTime = performance.now();

                try {
                    attackFunction();
                } catch (error) {
                    console.error('Attack execution error:', error);
                    this.attackLock = false;
                }


                if (!this._timers) this._timers = [];
                const unlockId = setTimeout(() => {
                    this.attackLock = false;
                    this._timers = this._timers.filter(t => t !== unlockId);
                }, duration);
                this._timers.push(unlockId);
            }


            scheduleTimeout(fn, delay) {
                if (!this._timers) this._timers = [];
                const id = setTimeout(() => {
                    try { fn(); } catch (e) { console.error('Scheduled timeout error:', e); }
                    this._timers = this._timers.filter(t => t !== id);
                }, delay);
                this._timers.push(id);
                return id;
            }

            scheduleInterval(fn, interval) {
                if (!this._timers) this._timers = [];
                const id = setInterval(() => {
                    try { fn(); } catch (e) { console.error('Scheduled interval error:', e); }
                }, interval);
                this._timers.push(id);
                return id;
            }


            reset() {
                if (this._timers) {
                    this._timers.forEach(id => { try { clearTimeout(id); clearInterval(id); } catch (e) { } });
                    this._timers = [];
                }
                this.attackLock = false;
                this.lastAttackTime = 0;

                super.reset();
            }



            teleport() {
                this.safeExecuteAttack(() => {
                    this.state = 'telegraph';
                    this.timer = 0.3;
                    particleManager.spawn({
                        x: this.x + this.w / 2,
                        y: this.y + this.h / 2,
                        count: 20,
                        color: this.particleColor,
                        speed: 300,
                        size: 4,
                        lifetime: 0.3,
                        glow: true
                    });

                    this.scheduleTimeout(() => {
                        if (!this.active || this.hp <= 0) return;
                        const player = game.player;
                        if (!player) return;

                        this.x = player.facing > 0 ? player.x - 150 : player.x + 150;
                        this.y = player.y;
                        this.state = 'idle';
                        this.timer = 0.5;

                        particleManager.spawn({
                            x: this.x + this.w / 2,
                            y: this.y + this.h / 2,
                            count: 20,
                            color: this.particleColor,
                            speed: 300,
                            size: 4,
                            lifetime: 0.3,
                            glow: true
                        });
                    }, 300);
                }, 800);
            }

            moonSlash(count = 1) {
                this.safeExecuteAttack(() => {
                    this.state = 'telegraph';
                    this.timer = 0.8;
                    audio.playSound('skill_moon');

                    this.scheduleTimeout(() => {
                        if (!this.active || this.hp <= 0) return;
                        this.state = 'idle';
                        this.timer = 1.2;

                        for (let i = 0; i < count; i++) {
                            this.scheduleTimeout(() => {
                                if (!this.active || !game.player) return;
                                const player = game.player;
                                const ang = Math.atan2(player.y - this.y, player.x - this.x);
                                const proj = projectilePool.get();
                                if (proj) {
                                    proj.activate(
                                        this.x + this.w / 2,
                                        this.y + this.h / 2,
                                        ang,
                                        600,
                                        20,
                                        this.particleColor,
                                        1.5,
                                        true
                                    );
                                }
                            }, i * 200);
                        }
                    }, 800);
                }, 1500);
            }

            multiSlash() {
                this.safeExecuteAttack(() => {
                    this.state = 'telegraph';
                    this.timer = 1.0;

                    this.scheduleTimeout(() => {
                        if (!this.active || this.hp <= 0) return;
                        const player = game.player;
                        if (!player) return;

                        this.state = 'idle';
                        this.timer = 2.0;

                        const ang = Math.atan2(player.y - this.y, player.x - this.x);
                        for (let i = -2; i <= 2; i++) {
                            const proj = projectilePool.get();
                            if (proj) {
                                proj.activate(
                                    this.x + this.w / 2,
                                    this.y + this.h / 2,
                                    ang + i * 0.2,
                                    500,
                                    15,
                                    this.particleColor,
                                    1.8,
                                    true
                                );
                            }
                        }
                    }, 1000);
                }, 2000);
            }

            moonVortex() {
                this.safeExecuteAttack(() => {
                    this.state = 'telegraph';
                    this.timer = 1.2;

                    this.scheduleTimeout(() => {
                        if (!this.active || this.hp <= 0) return;

                        this.state = 'idle';
                        this.timer = 3.0;
                        screenEffects.shake(0.8, 20);

                        for (let i = 0; i < 16; i++) {
                            const proj = projectilePool.get();
                            if (proj) {
                                proj.activate(
                                    this.x + this.w / 2,
                                    this.y + this.h / 2,
                                    (i / 16) * Math.PI * 2,
                                    400,
                                    25,
                                    this.particleColor,
                                    2.5,
                                    true
                                );
                            }
                        }
                    }, 1200);
                }, 2500);
            }
        }

        // ##################################################################
        // #                   PROJECTILES & OBJECT POOL                  #
        // ##################################################################
        class Projectile {
            constructor() {
                this.active = false;
            }
            activate(x, y, angle, speed, damage, color, lifetime, isCrescent = false, isClone = false) {
                Object.assign(this, { x, y, damage, color, lifetime, isCrescent, isClone, age: 0, active: true });
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                if (isClone) {
                    this.w = 70; this.h = 85; this.state = 'idle'; this.stateTimer = 1.0;
                }
            }
            update(dt) {
                if (!this.active) return;
                this.age += dt;

                if (this.isClone) {
                    this.stateTimer -= dt;
                    if (this.stateTimer <= 0 && this.state === 'idle') {
                        this.state = 'attacking';
                        const angle = Math.atan2(game.player.y - this.y, game.player.x - this.x);
                        this.vx = Math.cos(angle) * 300;
                        this.vy = Math.sin(angle) * 300;
                        this.stateTimer = 0.5;
                    }
                }

                this.x += this.vx * dt;
                this.y += this.vy * dt;

                if (this.collidesWith(game.player)) {
                    game.player.takeDamage(this.damage);
                    this.active = false;
                }

                if (this.isDead()) {
                    this.active = false;
                }
            }
            isDead() { return this.age >= this.lifetime; }
            collidesWith(e) {
                const effectiveWidth = this.isClone ? this.w : 8;
                const effectiveHeight = this.isClone ? this.h : 8;
                return this.x < e.x + e.w && this.x + effectiveWidth > e.x && this.y < e.y + e.h && this.y + effectiveHeight > e.y;
            }
            draw(ctx) {
                if (!this.active) return;
                ctx.save();

                const trailLength = Math.min(6, Math.floor((this.lifetime - this.age) * 10));
                ctx.globalCompositeOperation = 'lighter';
                for (let i = 0; i < 3; i++) {
                    const a = Math.max(0, 0.15 - i * 0.04) * (1 - (this.age / Math.max(0.0001, this.lifetime)));
                    ctx.fillStyle = this.color.replace(')', `, ${a})`).replace('rgb', 'rgba');
                    ctx.beginPath(); ctx.arc(this.x - this.vx * i * 0.02, this.y - this.vy * i * 0.02, 8 - i * 2, 0, Math.PI * 2); ctx.fill();
                }
                ctx.shadowColor = this.color; ctx.shadowBlur = 15; ctx.fillStyle = this.color;

                if (this.isClone) {
                    ctx.globalAlpha = 0.6 * (1 - this.age / this.lifetime);
                    ctx.fillRect(this.x, this.y, this.w, this.h);
                } else if (this.isCrescent) {
                    const angle = Math.atan2(this.vy, this.vx);
                    ctx.translate(this.x, this.y); ctx.rotate(angle); ctx.scale(1.5, 1);
                    ctx.beginPath();
                    ctx.arc(0, 0, 15, -Math.PI / 2, Math.PI / 2);
                    ctx.arc(0, 0, 10, Math.PI / 2, -Math.PI / 2, true);
                    ctx.closePath(); ctx.fill();
                } else {
                    ctx.beginPath(); ctx.arc(this.x, this.y, 8, 0, Math.PI * 2); ctx.fill();
                }
                ctx.restore();
            }
        }

        const projectilePool = {
            pool: [],
            maxSize: 50,

            init() {
                for (let i = 0; i < this.maxSize; i++) {
                    this.pool.push(new Projectile());
                }
            },

            get() {
                for (let i = 0; i < this.maxSize; i++) {
                    if (!this.pool[i].active) {
                        return this.pool[i];
                    }
                }

                let oldestIndex = 0;
                let oldestAge = -1;
                for (let i = 0; i < this.maxSize; i++) {
                    if (this.pool[i].age > oldestAge) {
                        oldestAge = this.pool[i].age;
                        oldestIndex = i;
                    }
                }
                console.warn("Projectile pool full — recycling oldest projectile.");
                const p = this.pool[oldestIndex];
                p.active = false;
                return p;
            }
        };

        // ##################################################################
        // #                         GAME LOGIC                           #
        // ##################################################################
        const game = {
            state: 'start', player: new Player(150, 500), camera: new Camera(GAME_WIDTH, GAME_HEIGHT),
            rooms: [], currentRoomIndex: 0, hitStop: 0, bossesDefeated: 0,
            timeScale: 1.0,
            colliders: [],
            init() {

                const save = SaveManager.load();
                if (save && save.unlockedStyles) {
                    this.player = new Player(150, 500);
                    this.player.unlockedStyles = save.unlockedStyles;
                    this.player.currentStyle = save.currentStyle || 0;
                }
                this.rooms.push(new Room({ w: 1280, h: 720, tiles: [new Tile(0, 650, 1280, 70), new Tile(400, 500, 150, 20), new Tile(700, 400, 150, 20), new Tile(100, 300, 200, 20),], doors: [new Door(1200, 550, 80, 100, 1, 100, 550)], }));
                this.rooms.push(new Room({ w: 1280, h: 720, tiles: [new Tile(0, 650, 400, 70), new Tile(880, 650, 400, 70), new Tile(400, 650, 480, 16, 'spike'), new Tile(600, 500, 80, 20, 'moving_h'), new Tile(300, 350, 150, 20), new Tile(850, 350, 150, 20), new Tile(0, 0, 20, 720), new Tile(1260, 0, 20, 720),], doors: [new Door(0, 550, 80, 100, 0, 1100, 550), new Door(1200, 250, 80, 100, 2, 100, 550),], healingOrbs: [new HealingOrb(620, 450)] }));
                this.rooms.push(new Room({ w: 1280, h: 720, tiles: [new Tile(0, 650, 1280, 70), new Tile(0, 0, 20, 720), new Tile(1260, 0, 20, 720),], doors: [new Door(0, 550, 80, 100, 1, 1100, 250), new Door(1200, 550, 80, 100, 3, 100, 550, () => game.bossesDefeated < 1)], bosses: [new Akaza(900, 570)], hashira: new Giyu(200, 590) }));
                this.rooms.push(new Room({ w: 1280, h: 720, tiles: [new Tile(0, 650, 1280, 70), new Tile(0, 0, 20, 720), new Tile(1260, 0, 20, 720), new Tile(500, 450, 200, 20)], doors: [new Door(0, 550, 80, 100, 2, 1100, 550), new Door(1200, 550, 80, 100, 4, 100, 550)], healingOrbs: [new HealingOrb(580, 400)] }));
                this.rooms.push(new Room({ w: 1280, h: 720, tiles: [new Tile(0, 650, 1280, 70), new Tile(0, 0, 20, 720), new Tile(1260, 0, 20, 720)], doors: [new Door(0, 550, 80, 100, 3, 1100, 550), new Door(1200, 550, 80, 100, 5, 100, 550, () => game.bossesDefeated < 2)], bosses: [new Doma(900, 565)], hashira: new Shinobu(200, 585) }));
                this.rooms.push(new Room({ w: 1920, h: 720, tiles: [new Tile(0, 650, 1920, 70), new Tile(0, 0, 20, 720), new Tile(1900, 0, 20, 720), new Tile(300, 500, 100, 20, 'moving_h'), new Tile(600, 400, 150, 16, 'spike'), new Tile(600, 380, 150, 20), new Tile(900, 250, 100, 20, 'moving_v'), new Tile(1200, 400, 150, 20), new Tile(1500, 500, 100, 20, 'moving_h'),], doors: [new Door(0, 550, 80, 100, 4, 1100, 550), new Door(1820, 550, 80, 100, 6, 100, 560)], healingOrbs: [new HealingOrb(1000, 200)] }));
                this.rooms.push(new Room({ w: 1280, h: 720, tiles: [new Tile(0, 650, 1280, 70), new Tile(0, 0, 20, 720), new Tile(1260, 0, 20, 720),], bosses: [new Kokushibo(900, 560)], hashira: new Gyomei(200, 580) }));
                this.currentRoom = this.rooms[this.currentRoomIndex];
                projectilePool.init();

                HashiraManager.register('giyu', { assist: () => { particleManager.spawn({ x: game.player.x, y: game.player.y, count: 80, color: '#4fc3f7', speed: 240, size: 6, lifetime: 1.2, glow: true }); game.checkHashiraAttack(game.player.x - 80, game.player.y - 40, 160, game.player.h + 60, 18, '#4fc3f7'); } });
                HashiraManager.register('shinobu', { assist: () => { particleManager.spawn({ x: game.player.x + 40, y: game.player.y, count: 60, color: '#ab47bc', speed: 180, size: 5, lifetime: 1.0, glow: true }); game.checkHashiraAttack(game.player.x - 40, game.player.y - 40, 120, game.player.h + 60, 12, '#ab47bc'); } });
                HashiraManager.register('gyomei', { assist: () => { particleManager.spawn({ x: game.player.x, y: game.player.y + 40, count: 100, color: '#a1887f', speed: 320, size: 8, lifetime: 1.4, glow: false }); game.checkHashiraAttack(game.player.x - 160, game.player.y - 60, 320, game.player.h + 120, 28, '#a1887f'); } });
            },
            reset() {
                this.player.reset(150, 500); this.rooms.forEach(r => r.reset());
                projectilePool.pool.forEach(p => p.active = false);
                this.currentRoomIndex = 0;
                this.currentRoom = this.rooms[0]; this.bossesDefeated = 0;

                this.colliders.length = 0;
                this.timeScale = 1.0;
            },
            setState(newState) {
                if (newState === 'gameOver' || newState === 'victory') {
                    if (gameLoopId) {
                        cancelAnimationFrame(gameLoopId);
                        gameLoopId = null;
                    }
                }
                this.state = newState;
                document.getElementById('start-screen').style.display = (newState === 'start') ? 'flex' : 'none';
                document.getElementById('game-over-screen').style.display = (newState === 'gameOver') ? 'flex' : 'none';
                document.getElementById('victory-screen').style.display = (newState === 'victory') ? 'flex' : 'none';
            },
            startBossEncounter() {
                const boss = this.currentRoom.bosses.find(b => b.hp > 0);
                if (!boss) return;
                const hashira = this.currentRoom.hashira;
                let dialogueSequence = [];
                if (boss.name.includes("Akaza")) {
                    dialogueSequence = [{ speaker: "Akaza", text: "Your fighting spirit is weak. Why even bother showing up, Giyu?" }, { speaker: "Giyu Tomioka", text: "I am not like you. I protect others." }, { speaker: "Akaza", text: "Become a demon! We could fight for eternity!" }];
                } else if (boss.name.includes("Doma")) {
                    dialogueSequence = [{ speaker: "Doma", text: "Oh? Another little slayer? You're not nearly as cute as the last one I ate." }, { speaker: "Shinobu Kocho", text: "For my sister... I will see you perish where you stand." }, { speaker: "Doma", text: "Such anger! It's not very becoming of you." }];
                } else if (boss.name.includes("Kokushibo")) {
                    dialogueSequence = [{ speaker: "Kokushibo", text: "A swordsman and... a Pillar of stone. How unsightly." }, { speaker: "Gyomei Himejima", text: "May the Buddha have mercy on your pitiful soul." }, { speaker: "Kokushibo", text: "Your prayers are wasted. There is only the blade." }];
                }
                if (dialogueSequence.length > 0) {
                    this.state = 'dialogue';
                    dialogueManager.start(dialogueSequence);
                } else {
                    this.state = 'playing';
                }
                boss.activate();
                if (hashira) hashira.activate();
            },
            update(dt) {
                if (this.state === 'dialogue') { dialogueManager.update(dt); return; }
                if (this.state === 'paused') return;
                if (this.hitStop > 0) { this.hitStop -= dt; return; }

                dt *= this.timeScale;
                try {
                    this.player.update(dt, this.currentRoom);
                } catch (e) {
                    console.error('Error updating player', e);
                }
                try {
                    this.currentRoom.update(dt);
                } catch (e) {
                    console.error('Error updating currentRoom', e);
                }

                try {
                    for (const k in spriteAnimators) {
                        const a = spriteAnimators[k]; if (a && typeof a.update === 'function') a.update(dt);
                    }
                } catch (e) { console.error('Animator update error', e); }
                this.camera.follow(this.player, this.currentRoom);
                particleManager.update(dt);
                screenEffects.update(dt);
                perfOverlay.update();
                for (let i = 0; i < projectilePool.pool.length; i++) {
                    const p = projectilePool.pool[i];
                    if (!p || !p.active) continue;
                    try {
                        p.update(dt);
                    } catch (err) {
                        console.error('Projectile update error', err);
                        p.active = false;
                    }
                }


                for (let i = this.colliders.length - 1; i >= 0; i--) {
                    const c = this.colliders[i];
                    c.life -= dt;
                    if (c.life <= 0) { this.colliders.splice(i, 1); continue; }

                    this.currentRoom.bosses.forEach(b => {
                        if (!b.active) return;
                        if (c.x < b.x + b.w && c.x + c.w > b.x && c.y < b.y + b.h && c.y + c.h > b.y) {
                            b.takeDamage(c.damage);
                            if (c.once) c.life = 0;
                        }
                    });
                }

                for (let i = this.currentRoom.healingOrbs.length - 1; i >= 0; i--) {
                    const orb = this.currentRoom.healingOrbs[i];
                    if (orb.active && this.player.x < orb.x + orb.w && this.player.x + this.player.w > orb.x && this.player.y < orb.y + orb.h && this.player.y + this.player.h > orb.y) {
                        orb.active = false; this.player.heal(50);
                    }
                }
                this.currentRoom.doors.forEach(d => {
                    if (this.player.x < d.x + d.w && this.player.x + this.player.w > d.x && this.player.y < d.y + d.h && this.player.y + this.player.h > d.y) {
                        if (d.isLocked()) return;
                        this.player.endAttack();
                        this.currentRoomIndex = d.toRoom;
                        this.currentRoom = this.rooms[this.currentRoomIndex];
                        this.player.x = d.entryX; this.player.y = d.entryY;
                        projectilePool.pool.forEach(p => p.active = false);
                        const bossToActivate = this.currentRoom.bosses.find(b => !b.active && b.hp > 0);
                        if (bossToActivate) { this.startBossEncounter(); }
                    }
                });
                keysToTrack.forEach(k => input[k + 'Pressed'] = false);
            },
            checkPlayerAttack(x, y, w, h, damage = 10) {
                this.currentRoom.bosses.forEach(b => {
                    if (b.active && x < b.x + b.w && x + w > b.x && y < b.y + b.h && y + h > b.y) {
                        b.takeDamage(damage);
                    }
                });
            },
            checkHashiraAttack(x, y, w, h, damage = 10, color = '#FFFFFF') {
                particleManager.spawn({ x: x + w / 2, y: y + h / 2, count: 15, color: color, speed: 100, size: 4, lifetime: 0.4 });
                this.currentRoom.bosses.forEach(b => {
                    if (b.active && x < b.x + b.w && x + w > b.x && y < b.y + b.h && y + h > b.y) {
                        b.takeDamage(damage);
                    }
                });
            },
            bossDefeated() {
                this.bossesDefeated++;
                this.player.heal(this.player.maxHp);
                if (this.bossesDefeated >= 3) { this.setState('victory'); }
            },
            draw() {
                ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                this.camera.apply(ctx);
                this.currentRoom.draw(ctx, this.camera);
                projectilePool.pool.forEach(p => { if (p.active) p.draw(ctx) });
                this.player.draw(ctx);
                particleManager.draw(ctx);
                this.camera.release(ctx);
                this.updateUI();

                perfOverlay.draw(ctx);
            },
            updateUI() {
                document.getElementById('hp-bar-inner').style.width = `${Math.max(0, this.player.hp / this.player.maxHp * 100)}%`;
                document.getElementById('focus-bar-inner').style.width = `${Math.max(0, this.player.focus / this.player.maxFocus * 100)}%`;
                const styleName = this.player.currentStyle === 0 ? "Water Breathing" : "Hinokami Kagura";
                document.getElementById('style-indicator').textContent = styleName;
                const currentSkills = this.player.skills[this.player.currentStyle];
                document.getElementById('skillF-cooldown').style.height = `${Math.max(0, currentSkills['F'].cooldown / currentSkills['F'].maxCooldown * 100)}%`;
                document.getElementById('skillX-cooldown').style.height = `${Math.max(0, currentSkills['X'].cooldown / currentSkills['X'].maxCooldown * 100)}%`;
                document.getElementById('skill1-cooldown').style.height = `${Math.max(0, currentSkills['1'].cooldown / currentSkills['1'].maxCooldown * 100)}%`;
                document.getElementById('skill2-cooldown').style.height = `${Math.max(0, currentSkills['2'].cooldown / currentSkills['2'].maxCooldown * 100)}%`;
                document.getElementById('skill3-cooldown').style.height = `${Math.max(0, currentSkills['3'].cooldown / currentSkills['3'].maxCooldown * 100)}%`;
                const bossBar = document.getElementById('boss-hud');
                const activeBoss = this.currentRoom.getActiveBoss();
                if (activeBoss) {
                    bossBar.style.opacity = '1';
                    document.getElementById('boss-name').textContent = activeBoss.name;
                    document.getElementById('boss-hp-bar-inner').style.width = `${Math.max(0, activeBoss.hp / activeBoss.maxHp * 100)}%`;
                    document.getElementById('boss-status-icon').textContent = activeBoss.poisonTimer > 0 ? '☠️' : '';
                } else {
                    bossBar.style.opacity = '0';
                }
                const hashiraHud = document.getElementById('hashira-hud');
                const activeHashira = this.currentRoom.hashira;
                if (activeHashira && activeHashira.active) {
                    hashiraHud.style.opacity = '1';
                    document.getElementById('hashira-name').textContent = activeHashira.name;
                    document.getElementById('hashira-state').textContent = `State: ${activeHashira.state.toUpperCase()}`;
                } else {
                    hashiraHud.style.opacity = '0';
                }
            },
        };

        // ##################################################################
        // #                          MAIN LOOP                           #
        // ##################################################################
        let lastTime = 0;
        let gameLoopId = null;

        function loop(timestamp) {
            try {
                const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
                lastTime = timestamp;
                if (game.state === 'playing' || game.state === 'dialogue') {
                    game.update(dt);
                }
                game.draw();
            } catch (err) {
                console.error('Unhandled error in main loop:', err);
                try {

                    const activeBoss = game.currentRoom && game.currentRoom.getActiveBoss && game.currentRoom.getActiveBoss();
                    if (activeBoss) {
                        console.warn('Deactivating boss to recover from error:', activeBoss.name);
                        activeBoss.active = false;
                    }
                } catch (ee) { console.error('Error while attempting recovery:', ee); }
            }
            gameLoopId = requestAnimationFrame(loop);
        }


        window.addEventListener('error', (e) => {
            console.error('Global error captured:', e.error || e.message, e.error && e.error.stack);
        });
        window.addEventListener('unhandledrejection', (e) => {
            console.error('Unhandled promise rejection:', e.reason, e.reason && e.reason.stack);
        });

        document.getElementById('start-screen').addEventListener('click', () => {
            if (assetManager.isDone() && !gameLoopId) {
                audio.init();
                game.reset();
                game.setState('playing');
                lastTime = performance.now();
                gameLoopId = requestAnimationFrame(loop);
            }
        });
        document.getElementById('game-over-screen').addEventListener('click', () => {
            if (!gameLoopId) {
                game.reset();
                game.setState('playing');
                lastTime = performance.now();
                gameLoopId = requestAnimationFrame(loop);
            }
        });
        document.getElementById('victory-screen').addEventListener('click', () => {
            if (!gameLoopId) {
                game.reset();
                game.setState('playing');
                lastTime = performance.now();
                gameLoopId = requestAnimationFrame(loop);
            }
        });


        window.addEventListener('keydown', (e) => {
            const isSpace = e.code === 'Space' || e.key === ' ' || e.key === 'Spacebar';
            if (!isSpace) return;

            try { e.preventDefault(); } catch (err) { }
            const ss = document.getElementById('start-screen');
            const go = document.getElementById('game-over-screen');
            const vs = document.getElementById('victory-screen');

            console.log('Space pressed: ss.display=', ss.style.display, 'assetDone=', assetManager.isDone(), 'gameLoopId=', !!gameLoopId);
            if ((ss.style.display !== 'none' || ss.style.display === '') && assetManager.isDone() && !gameLoopId) {
                audio.init(); game.reset(); game.setState('playing'); lastTime = performance.now(); gameLoopId = requestAnimationFrame(loop);
                return;
            }
            if (go.style.display !== 'none' && !gameLoopId) {
                game.reset(); game.setState('playing'); lastTime = performance.now(); gameLoopId = requestAnimationFrame(loop);
                return;
            }
            if (vs.style.display !== 'none' && !gameLoopId) {
                game.reset(); game.setState('playing'); lastTime = performance.now(); gameLoopId = requestAnimationFrame(loop);
                return;
            }
        });

        // --- GAME START SEQUENCE ---

        function generateSpriteSheets() {

            function makeSheet(name, cellW, cellH, cols, rows, drawCell) {
                const c = document.createElement('canvas');
                c.width = cellW * cols; c.height = cellH * rows;
                const g = c.getContext('2d');

                g.clearRect(0, 0, c.width, c.height);
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        g.save();
                        g.translate(x * cellW, y * cellH);
                        drawCell(g, x, y, cellW, cellH);
                        g.restore();
                    }
                }
                const img = new Image(); img.src = c.toDataURL();
                assetManager.images[name] = img;
            }


            makeSheet('tanjiro', 64, 64, 5, 1, (g, cx, cy, w, h) => {

                g.clearRect(0, 0, w, h);

                g.fillStyle = '#1f1f24'; g.fillRect(w * 0.25, h * 0.32, w * 0.5, h * 0.5);

                g.fillStyle = '#2b7f7a'; g.fillRect(w * 0.15, h * 0.32, w * 0.7, h * 0.5);
                g.fillStyle = '#143233';
                for (let i = 0; i < 4; i++) { g.fillRect(w * 0.15 + i * w * 0.175, h * 0.33, w * 0.085, h * 0.46); }

                g.fillStyle = '#f0d9bf'; g.beginPath(); g.ellipse(w * 0.5, h * 0.18, w * 0.22, h * 0.18, 0, 0, Math.PI * 2); g.fill();

                g.fillStyle = '#120809'; g.fillRect(w * 0.12, h * 0.0, w * 0.76, h * 0.24);

                g.fillStyle = '#fff'; g.fillRect(w * 0.4, h * 0.18, w * 0.06, h * 0.04); g.fillRect(w * 0.54, h * 0.18, w * 0.06, h * 0.04);

                const frame = cx; const tilt = (frame - 2) * 0.04;
                g.save(); g.translate(w * 0.5, h * 0.6); g.rotate(tilt); g.fillStyle = '#cfd8dc'; g.fillRect(-w * 0.02, -h * 0.05, w * 0.6, h * 0.06); g.restore();
            });


            makeSheet('hashira', 64, 72, 3, 1, (g, cx, cy, w, h) => {
                g.clearRect(0, 0, w, h);

                g.fillStyle = '#1f1f24'; g.fillRect(w * 0.2, h * 0.3, w * 0.6, h * 0.55);

                g.fillStyle = '#f0d9bf'; g.beginPath(); g.ellipse(w * 0.5, h * 0.14, w * 0.22, h * 0.16, 0, 0, Math.PI * 2); g.fill();

                if (cx === 0) {
                    g.fillStyle = '#0d47a1'; g.fillRect(w * 0.25, h * 0.36, w * 0.5, h * 0.18);
                } else if (cx === 1) {
                    g.fillStyle = '#e1bee7'; g.fillRect(w * 0.25, h * 0.36, w * 0.5, h * 0.18); g.fillStyle = '#ab47bc'; g.beginPath(); g.moveTo(w * 0.5, h * 0.36); g.bezierCurveTo(w * 0.4, h * 0.28, w * 0.6, h * 0.28, w * 0.5, h * 0.36); g.fill();
                } else {
                    g.fillStyle = '#6d4c41'; for (let i = 0; i < 4; i++) g.beginPath(), g.arc(w * (0.3 + i * 0.1), h * 0.45, w * 0.04, 0, Math.PI * 2), g.fill();
                }
            });


            makeSheet('bosses', 96, 96, 3, 1, (g, cx, cy, w, h) => {
                g.clearRect(0, 0, w, h);

                if (cx === 0) {
                    g.fillStyle = '#f8bbd0'; g.fillRect(w * 0.15, h * 0.18, w * 0.7, h * 0.6);
                    g.fillStyle = '#ff4081'; for (let i = 0; i < 4; i++) g.fillRect(w * (0.2 + i * 0.15), h * 0.22 + i * 6, w * 0.08, h * 0.08);
                }

                if (cx === 1) {
                    g.fillStyle = '#fff3e0'; g.fillRect(w * 0.15, h * 0.18, w * 0.7, h * 0.6);
                    g.fillStyle = '#b39ddb'; g.fillRect(w * 0.28, h * 0.3, w * 0.45, h * 0.2);
                }

                if (cx === 2) {
                    g.fillStyle = '#ede7f6'; g.fillRect(w * 0.12, h * 0.18, w * 0.76, h * 0.64);
                    g.fillStyle = '#6a1b9a'; g.fillRect(w * 0.12, h * 0.6, w * 0.76, h * 0.18);

                    g.fillStyle = '#ff1744'; for (let i = 0; i < 6; i++) g.fillRect(w * 0.2 + (i % 3) * 0.18 * w, h * 0.26 + Math.floor(i / 3) * 0.08 * h, w * 0.06, h * 0.04);
                }
            });


            makeSheet('tiles', 128, 128, 2, 1, (g, cx, cy, w, h) => {
                g.clearRect(0, 0, w, h);
                const grad = g.createLinearGradient(0, 0, w, h); grad.addColorStop(0, '#3a2b3b'); grad.addColorStop(1, '#201526'); g.fillStyle = grad; g.fillRect(0, 0, w, h);
                g.fillStyle = '#5a5278'; g.fillRect(w * 0.05, h * 0.55, w * 0.9, h * 0.35);
            });
        }


        assetManager.queueDownload('tanjiro', 'assets/tanjiro_sprites.png');
        assetManager.queueDownload('hashira', 'assets/hashira_sprites.png');
        assetManager.queueDownload('bosses', 'assets/boss_sprites.png');
        assetManager.queueDownload('tiles', 'assets/bg_tiles.png');

        assetManager.downloadAll(() => {
            game.init();



            try {
                const tImg = assetManager.getAsset('tanjiro');
                if (tImg) {
                    spriteAnimators.tanjiro = new SpriteAnimator(tImg, 64, 64, {
                        idle: { frames: [{ x: 0, y: 0, duration: 500 }] },
                        run: { frames: [{ x: 1, y: 0, duration: 80 }, { x: 2, y: 0, duration: 80 }] },
                        attack: { frames: [{ x: 3, y: 0, duration: 90 }, { x: 4, y: 0, duration: 90 }] }
                    });
                    spriteAnimators.tanjiro.play('idle', true);
                }

                const hImg = assetManager.getAsset('hashira');
                if (hImg) {
                    spriteAnimators.giyu = new SpriteAnimator(hImg, 48, 64, { idle: { frames: [{ x: 0, y: 0, duration: 500 }] } });
                    spriteAnimators.giyu.play('idle', true);
                    spriteAnimators.shinobu = new SpriteAnimator(hImg, 48, 64, { idle: { frames: [{ x: 1, y: 0, duration: 500 }] } });
                    spriteAnimators.shinobu.play('idle', true);
                    spriteAnimators.gyomei = new SpriteAnimator(hImg, 56, 72, { idle: { frames: [{ x: 2, y: 0, duration: 500 }] } });
                    spriteAnimators.gyomei.play('idle', true);
                }

                const bImg = assetManager.getAsset('bosses');
                if (bImg) {
                    spriteAnimators.akaza = new SpriteAnimator(bImg, 64, 80, { idle: { frames: [{ x: 0, y: 0, duration: 500 }] } });
                    spriteAnimators.akaza.play('idle', true);
                    spriteAnimators.doma = new SpriteAnimator(bImg, 70, 85, { idle: { frames: [{ x: 1, y: 0, duration: 500 }] } });
                    spriteAnimators.doma.play('idle', true);
                    spriteAnimators.kokushibo = new SpriteAnimator(bImg, 60, 90, { idle: { frames: [{ x: 2, y: 0, duration: 500 }] } });
                    spriteAnimators.kokushibo.play('idle', true);
                }
            } catch (e) {
                console.warn('Sprite animator initialization failed:', e);
            }

            game.setState('start');
        });
    </script>
</body>

</html>